# **Passkey-Based Wallet Discovery Standard: Extension-Less Blockchain Wallets via Web Standards and Iframes**

## **1\. Introduction**

### **1.1. Problem Statement**

The adoption of decentralized applications (DApps) has been persistently hindered by the reliance on browser extensions for wallet interactions. This traditional model, while foundational, introduces significant friction and security concerns that are misaligned with the vision of a seamless, user-centric Web3.[^1] Key challenges include:

- **Onboarding Friction:** The mandatory installation of browser-specific extensions creates a multi-step barrier to entry for new users, leading to high drop-off rates.
- **Security Vulnerabilities:** Browser extensions represent a significant attack surface, susceptible to phishing, supply-chain attacks, and permission overreach.
- **Platform Fragmentation:** The extension-based model lacks universal compatibility, failing to provide a consistent experience across different browsers and mobile environments.

### **1.2. Proposed Solution**

This document specifies a technical standard for the discovery and integration of passkey-based wallets that operates entirely within the browser, eliminating the need for extensions. By leveraging a combination of W3C standards—namely the **Payment Handler API** for discovery and **iframes** for secure interaction—this standard enables a secure, native, and frictionless wallet experience.[^2]

Wallet providers register themselves as payment handlers, creating a persistent but lightweight artifact in the browser. DApps can then use the standard Payment Request API to discover available wallets and initiate a secure signing process within a sandboxed iframe.

**Key Benefits:**

- **Truly Web-Native:** The entire workflow relies on established W3C standards, including the Payment Handler API, iframes, postMessage, and WebAuthn.
- **Frictionless Discovery:** DApps can perform silent, background checks for available wallets. If multiple wallets are registered, the browser presents a native, trusted UI for user selection.
- **Decentralized and Equitable:** The standard is open. Any wallet provider can register itself, and DApps can discover them dynamically without maintaining hardcoded lists or proprietary integrations.
- **Blocksense Compatibility:** The standard explicitly defines signature types that are verifiably compatible with the Blocksense protocol's ZK-native architecture, ensuring that passkey-generated signatures can be efficiently and objectively verified on-chain within Noir-based ZK circuits.[^1]

---

## **2\. Architecture Overview**

### **2.1. Components**

- **Wallet Provider:** A web application (e.g., my-wallet.com) where a user creates and manages their passkey-based wallet. This site is responsible for registering itself as a payment handler.
- **Relying Party (DApp):** A decentralized application (e.g., dapp.com) that needs to interact with a user's wallet to request signatures for transactions.
- **User Agent (Browser):** The browser acts as the trusted intermediary, managing payment handler registrations, facilitating discovery, and brokering secure access to WebAuthn credentials.
- **Blocksense Protocol:** The target blockchain that verifies the cryptographic proof (signature) generated by the wallet. Its ZK-native design allows for the efficient on-chain verification of supported signature schemes.[^1]

### **2.2. High-Level Workflow**

1. **One-Time Wallet Setup:** A user visits a Wallet Provider's website. During the account creation process, the user creates a passkey via the WebAuthn API (navigator.credentials.create()). Upon success, the Wallet Provider's service worker registers itself as a payment handler.
2. **Wallet Discovery:** The user visits a DApp and clicks "Connect Wallet." The DApp uses the Payment Request API to query the browser for any registered handlers that support the standard's specified payment method. If multiple compliant wallets are found, the browser natively prompts the user to select one.
3. **Secure Connection and Signing:** The DApp embeds a sandboxed iframe pointing to the origin of the selected Wallet Provider. The DApp uses postMessage to send the transaction data to the iframe. Inside the iframe, the Wallet Provider's script calls the WebAuthn API (navigator.credentials.get()) to request a signature from the user, triggering the browser's native biometric or security key prompt.
4. **On-Chain Verification:** The iframe returns the signature to the DApp via postMessage. The DApp then submits the transaction and signature to the Blocksense network, where it is verified within a ZK circuit.

---

## **3\. Technical Specification**

### **3.1. Wallet Provider: Registration**

A Wallet Provider **MUST** be a Progressive Web App (PWA) with a service worker. After a user successfully creates a passkey, the provider's service worker must register a payment instrument.

**3.1.1. Instrument Registration**

The registration is performed via navigator.paymentManager.instruments.set().

```javascript
// In the Wallet Provider's service worker (sw.js)

// A unique identifier for this standard
const METHOD_IDENTIFIER = 'https://passkey-wallet-standard.org/v1';

// After successful passkey creation and service worker registration
async function registerWalletInstrument(walletId) {
  if (!('paymentManager' in self.registration)) {
    return;
  }

  const instrument = {
    name: 'My Passkey Wallet', // User-visible wallet name
    icons: [
      {
        src: '/icons/wallet-icon-192.png',
        sizes: '192x192',
        type: 'image/png',
      },
    ],
    method: METHOD_IDENTIFIER,
    capabilities: {
      supportedSignatures: ['ecdsa-secp256r1', 'ecdsa-secp256k1'],
      supportedChains: ['blocksense', 'ethereum'],
    },
  };

  await self.registration.paymentManager.instruments.set(
    `passkey-wallet-${walletId}`, // A unique key for the instrument
    instrument,
  );
}
```

**3.1.2. Service Worker Event Handling**

The service worker must listen for and respond to two key events from the Payment Handler API.

```javascript
// In the Wallet Provider's service worker (sw.js)

// Respond affirmatively to availability checks from DApps.
self.addEventListener('canmakepayment', event => {
  event.respondWith(true);
});

// Respond to a discovery request with the wallet's details.
self.addEventListener('paymentrequest', event => {
  event.respondWith(
    new Promise(resolve => {
      resolve({
        methodName: METHOD_IDENTIFIER,
        details: {
          walletOrigin: new URL(self.registration.scope).origin,
          // Re-state capabilities for the DApp
          supportedSignatures: ['ecdsa-secp256r1', 'ecdsa-secp256k1'],
        },
      });
    }),
  );
});
```

### **3.2. Relying Party (DApp): Discovery and Connection**

When the user initiates a wallet connection, the DApp uses the PaymentRequest API to discover and connect to a compliant wallet.

```javascript
// In the DApp's frontend script

const METHOD_IDENTIFIER = 'https://passkey-wallet-standard.org/v1';

async function connectWallet() {
  if (!window.PaymentRequest) {
    // Fallback for unsupported browsers
    alert("This browser doesn't support extension-less wallets.");
    return;
  }

  const request = new PaymentRequest(
    [{ supportedMethods: METHOD_IDENTIFIER }],
    // A dummy total is required by the API
    {
      total: {
        label: 'Wallet Authentication',
        amount: { currency: 'USD', value: '0.00' },
      },
    },
  );

  const canConnect = await request.canMakePayment();
  if (!canConnect) {
    // Fallback if no compliant wallet is registered
    alert('No passkey wallet found. Please set one up first.');
    return;
  }

  try {
    const response = await request.show();
    const { walletOrigin } = response.details;

    // The transaction is "successful" from the API's perspective
    await response.complete('success');

    // Now, load the wallet's iframe to proceed with signing
    loadWalletIframe(walletOrigin);
  } catch (error) {
    console.error('Wallet connection failed:', error);
  }
}

function loadWalletIframe(walletOrigin) {
  const iframe = document.createElement('iframe');
  iframe.src = `${walletOrigin}/wallet-interface.html`; // Standardized path

  // Crucially, grant the iframe permission to use the WebAuthn API
  iframe.allow = 'publickey-credentials-get';

  document.body.appendChild(iframe);

  // Setup postMessage communication channel
  //... (see next section)
}
```

### **3.3. Secure Communication and Signing**

Communication between the DApp and the Wallet Provider's iframe **MUST** use postMessage with strict origin checks.

**3.3.1. DApp to Iframe: Requesting a Signature**

```javascript
// In the DApp's frontend script

// Assuming `iframe` and `walletOrigin` are available from the previous step
iframe.addEventListener('load', () => {
  const transactionToSign = {
    /*... transaction data... */
  };
  iframe.contentWindow.postMessage(
    { action: 'requestSignature', data: transactionToSign },
    walletOrigin,
  );
});
```

**3.3.2. Iframe to DApp: Returning the Signature**

The Wallet Provider's iframe page must be served with a Permissions-Policy HTTP header to enable WebAuthn.

**Example HTTP Header:**

```
Permissions-Policy: publickey-credentials-get=*
```

```javascript
// In the Wallet Provider's iframe script

window.addEventListener('message', async event => {
  // IMPORTANT: Verify the message is from the expected DApp origin
  if (event.origin !== 'https://dapp.com') {
    return;
  }

  if (event.data.action === 'requestSignature') {
    try {
      const credential = await navigator.credentials.get({
        publicKey: {
          challenge: new Uint8Array(event.data.data.challenge),
          //... other WebAuthn options
        },
      });

      // Send the signature back to the DApp
      window.parent.postMessage(
        { action: 'signatureResponse', signature: credential.response },
        'https://dapp.com', // Target the DApp's origin
      );
    } catch (error) {
      // Handle errors (e.g., user cancellation)
      window.parent.postMessage(
        { action: 'signatureError', error: error.message },
        '*',
      );
    }
  }
});
```

---

## **4\. Signature Types for On-Chain Verification**

A key requirement of this standard is ensuring that signatures generated via WebAuthn can be verified by Blocksense's ZK-native protocol. Wallet providers **MUST** declare the signature algorithms they support in their registration capabilities. The following table outlines the recommended signature types based on their WebAuthn compatibility and verifiability within Noir ZK circuits.

| Signature Type      | Algorithm Details                                  | Noir Support Status   | WebAuthn Compatibility   | Blocksense Use Case                                                                                                                  |
| :------------------ | :------------------------------------------------- | :-------------------- | :----------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| **ECDSA secp256r1** | ECDSA over NIST P-256 curve (ES256).               | **Native**            | **Yes (Default)**        | Primary algorithm for passkey-based transaction signing due to its robust security and native support.                               |
| **ECDSA secp256k1** | ECDSA over the secp256k1 curve.                    | **Native**            | Partial (via extensions) | Essential for cross-chain compatibility, especially for interacting with Ethereum-based assets via the Blocksense bridge.            |
| **RSA-PKCS1-v1_5**  | RSA with PKCS#1 v1.5 padding and SHA-256.          | **Community Library** | Yes (legacy support)     | Enables verification of signatures from older hardware tokens or systems, such as DKIM email verification for Web2 interoperability. |
| **Schnorr**         | Schnorr signatures over secp256k1 or other curves. | **Community Library** | No (not standard)        | Useful for advanced cryptographic schemes like efficient multi-signatures within autonomous agents.                                  |
| **EdDSA**           | Edwards-curve DSA over Ed25519.                    | **Community Library** | No (not standard)        | Ideal for privacy-preserving applications and ZK proof aggregation within the ADFS.                                                  |

---

## **5\. Security and Privacy Considerations**

- **Iframe Sandboxing:** The use of iframes naturally sandboxes the Wallet Provider's code from the DApp, preventing direct access to the DOM or JavaScript environment and mitigating cross-site scripting (XSS) risks.
- **Origin Verification:** Both the DApp and the Wallet Provider **MUST** perform strict origin checks on all messages received via postMessage to prevent malicious cross-window communication.
- **User Activation:** WebAuthn calls like `navigator.credentials.get()` require a transient user activation (e.g., a click) within the iframe, preventing drive-by signing attempts.[^5]
- **Discovery Privacy:** The canMakePayment() check is designed to be privacy-preserving. It returns a simple boolean without revealing which specific wallets are installed until the user explicitly consents by interacting with the show() prompt.

## **6\. Future Extensions**

- **Hybrid Passkeys:** As browser support for synced passkeys (via iCloud, Google Password Manager, etc.) matures, this standard will seamlessly support them, enabling users to access their wallets across all their devices without manual export/import.
- **Expanded Capabilities:** The capabilities object in the payment instrument registration can be extended to advertise support for other features, such as specific on-chain account abstraction modules or privacy-preserving protocols.

## **Works Cited**

[^1]: [[Blocksense Litepaper|blocksense-litepaper]] - Core protocol overview and design principles

[^2]: [Payment Handler API](https://www.w3.org/TR/payment-handler/) - W3C, accessed July 31, 2025

[^3]: [Web Authentication: An API for accessing Public Key Credentials - Level 2](https://www.w3.org/TR/webauthn-2/) - W3C, accessed July 31, 2025

[^4]: [ECDSA Signature Verification](https://noir-lang.org/docs/noir/standard_library/cryptographic_primitives/ecdsa_sig_verification) | Noir Documentation, accessed July 31, 2025

[^5]: [Passkeys & iframes: How to Create & Login with a Passkey?](https://www.corbado.com/blog/iframe-passkeys-webauthn) - Corbado, accessed July 31, 2025

[^6]: [richardliang/noir-rsa: Noir implementation of RSA-verify](https://github.com/richardliang/noir-rsa) - GitHub, accessed July 31, 2025

[^7]: [noir-lang/schnorr](https://github.com/noir-lang/schnorr) - GitHub, accessed July 31, 2025

[^8]: [noir-lang/eddsa](https://github.com/noir-lang/eddsa) - GitHub, accessed July 31, 2025
