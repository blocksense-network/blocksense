{"transpiled":true,"noir_version":"1.0.0-beta.5+0000000000000000000000000000000000000000","name":"AggregatedDataFeedStore","functions":[{"name":"constructor","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","brillig_names":["constructor"]},{"name":"get_2_slots_at_index","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"feed_id","type":{"kind":"field"},"visibility":"private"},{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"start_slot","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5386739060800882143":{"error_kind":"string","string":"Function get_2_slots_at_index can only be called statically"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBPJwAABAMnAgQEAycCBQQAHwoABAAFgEouCIBKAAEuCIBLAAIuCIBMAAMlAAAAeSUAAADXACIBAgIoAgADBIBNJwIEBAIuAgACgAMuAgADgAQuAgAEgAUlAAACdCgCAAIEgE0nAgMEAjsOAAMAAiwAgEMAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAoAIBEACAAKACARQAAAisAgEYGAAgAAAAAAAAAAAAAAAAAACgAgEcBAAEoAIBIBAABKACASQAAASYlAAACuh4CAAUAHgIABgAzKgAFAAYAByQCAAcAAAD7JQAAAuMeAgAFCQsiAAWASQAGJAIABgAAARUlAAAC9ScCBgQHLQgABy0KAQgtCgIJAAgABgAlAAADBy0CAAAtCggFACoFAwYBIgAGgEkABQEiAAGASQAGJwIHAAAnAgkECi0IAAotCgYLLQoHDAAIAAkAJQAAAwctAgAALQoLCAwqBQgGJAIABgAAAYsnAgUEADwGBQEtCAEFJwIGBAMACAEGAScDBQQBACIFAgYtCgYILQ4HCAAiCAIILQ4HCC0IAQYAAAECAS0OBQYcCgMHBBwKBwUAHAoFAwQnAgUEAi0KAwQjAAAB3gwqBAUDJAIAAwAAAfUjAAAB8C0LBgEmHAoEBwAnAgkECi0IAAotCgELLQoCDAAIAAkAJQAAAwctAgAALQoLCAAqCAcJLwoACQAHLQsGCCQCAAMAAAI5JQAABNkuAgAIgAMoAIAEBAADJQAABOsuCIAFAAMAIgMCCQAqCQQKLQ4HCi0OAwYBIgAEgEgAAy0KAwQjAAAB3gEAgAOABYAHLgCAA4AILgCABIAJCwCACIAHgAokAIAKAAACuS4BgAiABi4EgAaACQEAgAgAAoAIAQCACQACgAkjAAACiCYoAIAEBHgADQAAAIAEgAMkAIADAAAC4ioBAAEF96Hzr6Wt1Mo8BAIBJioBAAEFvh4//z6k9vo8BAIBJioBAAEFSsGKorjCBd88BAIBJiUAAAK6HAoBBQYcCgUEABwKBAEGJwIEAngaKgEEBRwKBQYCHAoGBAYrAgAGBgEAAAAAAAAAAAAAAAAAAAAGKgEGBwQqBwYIAioBCAUNIgAFgEYAASQCAAEAAANsJwIGBAA8BgYBJwIBBiAMKgQBBiQCAAYAAAOHJwIBBAA8BgEBHAoEAQAcCgUEABwKAgYGHAoGBQAcCgUGBigCAAUGIAAMKgYFByQCAAcAAAO9JwIFBAA8BgUBBSIABIBEAAUBKIBDAAUABAAqBAIFLQgBAgAAAQIBLgyASQACJwIGBAInAgcBAS0IAQQnAggEIQAIAQgBJwMEBAEAIgQCCCcCCQQgQwOqAAEABgAJAAcACCcCCgQgLgIACIADLgIACoAEJQAABXknAgEEIScCBgQgLgiASAADIwAABEAMKgMBByQCAAcAAARgIwAABFItCwIBBCoFAQItCgIBJi0LAgcEKgcHCAIqBgMHDioDBgkkAgAJAAAEgCUAAAX5DCoHBgkkAgAJAAAEkiUAAATZACIEAgoAKgoHCy0LCwkcCgkHAAUiAAiARQAJBCoHCQoDKIBJAAcACQQqCQgHACoKBwgtDggCASIAA4BIAActCgcDIwAABEAqAQABBcVrxFoOEAACPAQCASYuAYADgAYLAIAGAAKAByQAgAcAAAUGIwAABREuAIADgAUjAAAFeC4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAVkLgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAUzKAGABQQAAQMAgAYAAoAGIwAABXgmKACABgQAAgcAgASABoAFLgCABIAIKACACQQAAA0AgAmABYAKFwCACoAKJACACgAABfgDAIAIAAKACAEAgAOACYALLgGAC4AGAQCAA4AIgAsuAYALgAcBAIADgAmACy4EgAeACwEAgAOACIALLgSABoALAQCACQACgAkjAAAFlSYqAQABBSiGkrBH3P1DPAQCASY=","debug_symbols":"tZndTuM8EIbvpcc9sD3+G24FIVSgrCpVBXXhkz4h7n3nTTxOimQvuFoO6JNJ8nbGM/Yk7sfmaf/w/uv+cHp++b25uf3YPJwPx+Ph1/3x5XH3dng5ifVjY/DPOfnwW/kMm5sknyTH1gCygBXwsUCwArg2wBIEoi+QnEISgE52CrEAGwWvwDOQ8Qq5gMXtGQBBFoCDThwjIgELyAW8WnwqAFdnCAWiUagWLpBwewRAEN8Onydgq4C74AZ8Bnj4PINarFqsWhwppALkFGIBbxSCgtxOEqkPXkEt8JDEZ89yO7ntJhjxkAgAi6QgWKsQFLgA/JkhFyC1UCrgcXsEiKCXLw1BfCYPiAWQ9xm4uJFCAeR9hlSASSHPEA0plGvi5LNAyijHCUIBVgtS4CXSbIwCLOJGtkYBFokiY3gnQDgzqAW14SOAC8RUAGU8Ay6WvOdsFdSC6p2BZ2CE4zNAAvSSQbZiCQaQCzi1YOSDZJApFEABzKCnAimIY0FiZxRtkJAZtRo8ABeLq4wBnyEVwIAH+IMBB1hjqFJSwhQrVG2u2ly1UbWhQmcKplJUivW6jO+VcbAWRRkNCCmKFoQVZz7rZCijm0jGMhKIfKVqw7SeCaVYqNowNjMlfIefKCjlastQDhNBOYIYKpJDcQrK8N5NnvJEoXg/rZKFoGI+P7cbXUzv3877PdbS1eoqa+7r7rw/vW1uTu/H43bz3+74Pl30+3V3mj7fdmc5K5r705N8iuDz4bgHfW6Xu037VkvEerul4EKV4HChYTsaknGVMN4tCu5CwbUVPJtUFDzbWBXiZRzUVsgek2dSkEnqWwrdKJg1CslpK4pwdRTx30YRcs1FbuYidxRC0ihsJGr5wG0FWXp8UZDFJ10ZhcyWVhS9unYRC8Us4WKmZl13yjJJ5y8aiZJtBtKpS3ZGJdi53JL4QSTNGWp6dZU1Izn4RSF8CST2khq4JpWvlogmXy2xKoyfSMScqgSPeRGx8M8SyYx5kWwNJFFsSbhOdTLVpEr7X6aZzZcSneqUp1/1QvrASiJdSvi2hOOs1UlmNRZfJTrrprT1FOp0N6ucfAnl2wMam/XZm2h2KS48GizLr7ucaK6zemb505mWMzfz2pNgq+00sxuUIFslPI1J1CU482osfiDBpgbCpj1Z+17UZiQSzUDI91bgWL1w7fn+XQlazbSfSJCtgRC1JVKnG2XSJzV5sWl2I+oMZ4pOKzzF2OxGxL1Z4pmWWeLiSEuTF4PlibEzor7/vFa7s3AygyLsl6XH8qjIMiTGxSERvA8tz5+GxkSsW4l4HhSJaRHJg+FYXj3C2cFwnF0agyM7sqrLq6dfaq099b6v4f2QRgqxaqTsxjQorDToeg0eG1PZR1neMkyz24bQ65Scaqds9/yuBLu4tLnQlOgsqrKzqJE42acZ8yKZpVO6EQnplLa2udQM5C9pXUo0t+dbP5L6aCwbUzQYiV8athmUWD022KslaNCLOk3YeLo6q6tF40cSdUNACmMwEJ9atXUnR7vHw/liT/8TWufD7uG4L4fP76fH1dm3/1/1jP4m8Hp+edw/vZ/3UFp+GJB/t7LttXXe3sm+F45kF9ZFI0eymXgrXWIrazzO4VJ51ZfDhMPpWnnvdZHuPuHoHw==","brillig_names":["get_2_slots_at_index"]},{"name":"get_2_slots_latest_index","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"feed_id","type":{"kind":"field"},"visibility":"private"},{"name":"start_slot","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"11104102707179475981":{"error_kind":"string","string":"Function get_2_slots_latest_index can only be called statically"},"13265554733035650515":{"error_kind":"string","string":"BigNum::validate_gt check fails"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIDZJwAABAMnAgMEAicCBAQAHwoAAwAEgNUuCIDVAAEuCIDWAAIlAAAAcyUAAAwqACIBAgIoAgADBIDXJwIEBAIuAgACgAMuAgADgAQuAgAEgAUlAAAWOCgCAAIEgNcnAgMEAjsOAAMAAigAgEMEACwrAIBEAP/u7u7u7u7u7u7u7u7u7u8rAIBFBgAIAAAAAAAAAAAAAAAAAAAoAIBGAAACKQCARwYAAQAAKACASAYAAC4AAAGASSgAgEoEAAQBAAABgEoAASgBgEkEAAEBAIBJAAKASi4AgEqASy4EgEeASwEAgEsAAoBLLgSASIBLAQCASwACgEsuBIBIgEsoAIBKAQAAKwCASwYBAAAAAAAAAAAAAAAAAAAALACATAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAACgAgE0AIAArAIBOBgCAAAAAAAAAAAAAAAAAAAAoAIBPBAABKACAUAQADigAgFEEAAIoAIBSBAAPKACAUwQAGigAgFQEABQoAIBVBAADKACAVgQAECgAgFcEAEQoAIBYBABQKACAWQQAGygAgFoEABUoAIBbBAA4KACAXAQAMigAgF0EAAQoAIBeBAARKACAXwQAQSgAgGAEAGAoAIBhBABFKACAYgQAUSgAgGMEAGkoAIBkBABjKACAZQQAHCgAgGYEABYoAIBnBABWKACAaAQAWigAgGkEADkoAIBqBAAzKACAawQASCgAgGwEACooAIBtBAAFKACAbgQAfigAgG8EABIoAIBwBABCKACAcQQAMCgAgHIEAF4oAIBzBABhKACAdAQAVCgAgHUEAEYoAIB2BAB8KACAdwQAUigAgHgEAHooAIB5BABqKACAegQAZCgAgHsEAHIoAIB8BABsKACAfQQAHSgAgH4EABcoAIB/BABNKACAgAQAZigAgIEEAFcoAICCBABbKACAgwQAdygAgIQEAHQoAICFBAA6KACAhgQANCgAgIcEAD0oAICIBABuKACAiQQASSgAgIoEACUoAICLBAArKACAjAQAHygAgI0EAAYoAICOBAB/KACAjwQADSgAgJAEABkoAICRBAATKACAkgQAQygAgJMEAE8oAICUBAA3KACAlQQAMSgAgJYEAEAoAICXBABfKACAmAQAaCgAgJkEAGIoAICaBABVKACAmwQAWSgAgJwEAEcoAICdBAApKACAngQAfSgAgJ8EAC8oAICgBABdKACAoQQAUygAgKIEAHsoAICjBAB5KACApAQAcSgAgKUEAGsoAICmBABMKACApwQAZSgAgKgEAHYoAICpBABzKACAqgQAPCgAgKsEAG0oAICsBAAkKACArQQAHigAgK4EAAwoAICvBAAYKACAsAQATigAgLEEADYoAICyBAA/KACAswQAZygAgLQEAFgoAIC1BAAoKACAtgQALigAgLcEAFwoAIC4BAB4KACAuQQAcCgAgLoEAEsoAIC7BAB1KACAvAQAOygAgL0EACMoAIC+BAALKACAvwQANSgAgMAEAD4oAIDBBAAnKACAwgQALSgAgMMEAG8oAIDEBABKKACAxQQAIigAgMYEAAooAIDHBAAmKACAyAQAISgAgMkEAAkoAIDKBAAgKACAywQACCgAgMwEAAcoAIDNBACALgAAAYDOKACAzwQAgQEAAAGAzwABKAGAzgQAAQEAgM4AAoDPLgCAz4DQLgSAT4DQAQCA0AACgNAuBIBQgNABAIDQAAKA0C4EgFGA0AEAgNAAAoDQLgSAUoDQAQCA0AACgNAuBIBTgNABAIDQAAKA0C4EgFSA0AEAgNAAAoDQLgSAVYDQAQCA0AACgNAuBIBWgNABAIDQAAKA0C4EgFeA0AEAgNAAAoDQLgSAWIDQAQCA0AACgNAuBIBZgNABAIDQAAKA0C4EgFqA0AEAgNAAAoDQLgSAW4DQAQCA0AACgNAuBIBcgNABAIDQAAKA0C4EgF2A0AEAgNAAAoDQLgSAXoDQAQCA0AACgNAuBIBfgNABAIDQAAKA0C4EgGCA0AEAgNAAAoDQLgSAYYDQAQCA0AACgNAuBIBigNABAIDQAAKA0C4EgGOA0AEAgNAAAoDQLgSAZIDQAQCA0AACgNAuBIBlgNABAIDQAAKA0C4EgGaA0AEAgNAAAoDQLgSAZ4DQAQCA0AACgNAuBIBogNABAIDQAAKA0C4EgGmA0AEAgNAAAoDQLgSAaoDQAQCA0AACgNAuBIBrgNABAIDQAAKA0C4EgGyA0AEAgNAAAoDQLgSAbYDQAQCA0AACgNAuBIBugNABAIDQAAKA0C4EgG+A0AEAgNAAAoDQLgSAcIDQAQCA0AACgNAuBIBxgNABAIDQAAKA0C4EgHKA0AEAgNAAAoDQLgSAc4DQAQCA0AACgNAuBIB0gNABAIDQAAKA0C4EgHWA0AEAgNAAAoDQLgSAdoDQAQCA0AACgNAuBIB3gNABAIDQAAKA0C4EgHiA0AEAgNAAAoDQLgSAeYDQAQCA0AACgNAuBIB6gNABAIDQAAKA0C4EgHuA0AEAgNAAAoDQLgSAfIDQAQCA0AACgNAuBIB9gNABAIDQAAKA0C4EgH6A0AEAgNAAAoDQLgSAf4DQAQCA0AACgNAuBICAgNABAIDQAAKA0C4EgIGA0AEAgNAAAoDQLgSAgoDQAQCA0AACgNAuBICDgNABAIDQAAKA0C4EgISA0AEAgNAAAoDQLgSAhYDQAQCA0AACgNAuBICGgNABAIDQAAKA0C4EgIeA0AEAgNAAAoDQLgSAiIDQAQCA0AACgNAuBICJgNABAIDQAAKA0C4EgIqA0AEAgNAAAoDQLgSAi4DQAQCA0AACgNAuBICMgNABAIDQAAKA0C4EgI2A0AEAgNAAAoDQLgSAjoDQAQCA0AACgNAuBICPgNABAIDQAAKA0C4EgJCA0AEAgNAAAoDQLgSAkYDQAQCA0AACgNAuBICSgNABAIDQAAKA0C4EgJOA0AEAgNAAAoDQLgSAlIDQAQCA0AACgNAuBICVgNABAIDQAAKA0C4EgJaA0AEAgNAAAoDQLgSAl4DQAQCA0AACgNAuBICYgNABAIDQAAKA0C4EgJmA0AEAgNAAAoDQLgSAmoDQAQCA0AACgNAuBICbgNABAIDQAAKA0C4EgJyA0AEAgNAAAoDQLgSAnYDQAQCA0AACgNAuBICegNABAIDQAAKA0C4EgJ+A0AEAgNAAAoDQLgSAoIDQAQCA0AACgNAuBIChgNABAIDQAAKA0C4EgKKA0AEAgNAAAoDQLgSAo4DQAQCA0AACgNAuBICkgNABAIDQAAKA0C4EgKWA0AEAgNAAAoDQLgSApoDQAQCA0AACgNAuBICngNABAIDQAAKA0C4EgKiA0AEAgNAAAoDQLgSAqYDQAQCA0AACgNAuBICqgNABAIDQAAKA0C4EgKuA0AEAgNAAAoDQLgSArIDQAQCA0AACgNAuBICtgNABAIDQAAKA0C4EgK6A0AEAgNAAAoDQLgSAr4DQAQCA0AACgNAuBICwgNABAIDQAAKA0C4EgLGA0AEAgNAAAoDQLgSAsoDQAQCA0AACgNAuBICzgNABAIDQAAKA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CgEAgAsAAoALIwAAIwUoAYAFBAABAwCABgACgAYjAAAjSiYlAAAWfgEiAAGATwADLQsDAhwKAgMAHAoDAgArAgAEAAD///////////////////8OKgIEBSQCAAUAACONJQAAKu0BIgABgFEAAy0LAwIcCgIDABwKAwIAKwIABAAA////////////////////DioCBAUkAgAFAAAjyiUAACrtASIAAYBVAAMtCwMCHAoCAQAcCgECACkCAAMAAAH//w4qAgMEJAIABAAAI/slAAAq7SYqAQABBbgYt77rF33TPAQCASYlAAAWficCBQQGLQgABi0KAQcACAAFACUAABbeLQIAAC0KBwMtCggEHAoCBQYcCgUBABwKAQUGKAIAAQYgAAwqBQEGJAIABgAAJGInAgEEADwGAQEFIgAEgE0AAQEogEwAAQAEACoEAgEnAgQEBS0IAAUuCIBGAAYtCgMHAAgABAAlAAAYuS0CAAAtCgYCBCoBAgMtCgMBJioBAAEFxWvEWg4QAAI8BAIBJioBAAEFvh4//z6k9vo8BAIBJigAgAYEAAIHAIAEgAaABS4AgASACCgAgAkEAAANAIAJgAWAChcAgAqACiQAgAoAACVJAwCACAACgAgBAIADgAmACy4BgAuABgEAgAOACIALLgGAC4AHAQCAA4AJgAsuBIAHgAsBAIADgAiACy4EgAaACwEAgAkAAoAJIwAAJOYmJQAAFn4tCAEDAAABAgEuDIDPAAMuCIDPAAIjAAAlaQ0iAAKAVQAEJAIABAAAJX4jAAAnWgMogFEAAgAEDyIAAoBRAAUkAgAFAAAlmyUAABePDSIABIBVAAUkAgAFAAAlsCUAACSmACIBAgYAKgYEBy0LBwUNKIBIAAUABiQCAAYAACXkIwAAJdMBIgACgE8ABC0KBAIjAAAlaQUogLgABAACJwIHBAAKKgcEBiQCAAYAACYYBioCBAkLIgAJgLgACCQCAAgAACYYJQAAF30LIgAFgEgABCQCAAQAACcvIwAAJi0bIgAFgNEABBIqBQQGJwIEAgIaKgYEBRIqBgUEJwIFAgQaKgQFBhIqBAYFJwIEAggaKgUEBhIqBQYEJwIFAhAaKgQFBhIqBAYFJwIEAiAaKgUEBhIqBQYEJwIFAkAaKgQFBhIqBAYFHAoFBAArAgAFAAH8EML7z0cbkTsUzSWV1tUEKgQFBhwKBgUGHAoFBAAcCgQFBicCBAJ5GioFBAYcCgYEABwKBAUAKQIABwD/////DioFBwgkAgAIAAAm8SUAACrtHAoGBQQcCgUEBhwKBAUEDSIABYDNAAQkAgAEAAAnFSUAACSmASCAzgACAAYAKgYFBy0LBwQtCgQBIwAAJzouCIDPAAEjAAAnOgAqAgEEDioCBAUkAgAFAAAnUSUAABdrLQ4EAyMAACdaLQsDASYlAAAWfi0IAQQnAgUEBAAIAQUBJwMEBAEAIgQCBS0KBQYuDIBIAAYAIgYCBi4MgEgABgAiBgIGLgyASAAGLQgBBQAAAQIBByIAAoC4AAYHIgACgLgACAUiAAiAuAAJAioCCQccCgcIAhwKCAIEHAoCBwIDKIDUAAcAAg8iAAeA1AAIJAIACAAAJ+4lAAAXjwEiAAGATwAJLQsJCBoqCAIJLQgBCgAAAQIBLQ4JChgqCAcJJwIIAoAMKgcICyQCAAsAACgoJQAAKv8rAgALBgEAAAAAAAAAAAAAAAAAAAAGKgkLDAQqDAsNAioJDQgNIgAGgFUACSQCAAkAAChhJQAAJKYuAgAEgAMoAIAEBAAEJQAAIr0uCIAFAAkAIgkCCwAqCwYMLQ4IDC0OCQUDKIBVAAYABA8iAAaAVQAIJAIACAAAKKglAAAXjy4IgE8AAyMAACizDCoDBAgkAgAIAAAoyiMAACjFLQsFASYNIgADgFUACCQCAAgAACjfJQAAJKYAIgECCQAqCQMLLQsLCBgqCAcJLQsKCwAqCQsMDioJDA0kAgANAAApDSUAABdrKwIACwYBAAAAAAAAAAAAAAAAAAAABioMCw0EKg0LDgIqDA4JACoDBgsOKgMLDCQCAAwAAClIJQAAF2stCwUMDSIAC4BVAA0kAgANAAApYSUAACSmLgIADIADKACABAQABCUAACK9LgiABQANACINAg4AKg4LDy0OCQ8tDg0FGioIAgktDgkKASIAA4BPAAgtCggDIwAAKLMlAAAWfi0IAQMAAAECAQEiAAGAVQAFLQsFBBsiAASA0QAFLgIAAYADKACABAQABCUAACK9LgiABQAGACIGAgcBIgAHgFEACC0OBQgtDgYDHAoEBQEcCgUBBicCBAJ3GCoBBAUtCAEBAAABAgEtDgUBLgiATwACIwAAKiANIgACgFUABSQCAAUAACo6IwAAKjUtCwMBJi0LAwUDKIBRAAIABg8iAAKAUQAHJAIABwAAKlslAAAXjw0iAAaAVQAHJAIABwAAKnAlAAAkpgAiBQIIACoIBgktCwkHGyIAB4DRAAgtCwEJACoICQoOKggKCyQCAAsAACqhJQAAF2suAgAFgAMoAIAEBAAEJQAAIr0uCIAFAAgAIggCCQAqCQYLLQ4KCy0OCAMYKgcEBREiAAWATgAGLQ4GAQEiAAKATwAFLQoFAiMAACogKgEAAQVaAuQbtR6pnzwEAgEmKgEAAQXJb5M7E53pFjwEAgEm","debug_symbols":"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","brillig_names":["get_2_slots_latest_index"]},{"name":"get_4_slots_at_index","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"feed_id","type":{"kind":"field"},"visibility":"private"},{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"start_slot","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"7032277157694375098":{"error_kind":"string","string":"Function get_4_slots_at_index can only be called statically"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZnRbts6DIbfJde9kEhRIvcqwzBkbToECNIiaw9wUPTdD2mLslNAOq2D9aL5TNt/SImkFPtt93D49fr75/H8+PRn9+372+7X5Xg6HX//PD3d71+OT2e1vu2C/QPQj3Snn7T7VvQT9TgGA1aICilXoKhg15JZSCGnCgUcioLpMDjkChIckoPMgCE5cIVot7OBCYoCgINaQD1EVJdBHcMUHJpFKhA6lAoZHNxSooPdnhXYBM0N5gqCDnaXupFCdMgVoluiW8AtNrozSAVMDlwhoYN/BYGDC+bg4IJZBVFHI5Xk4BZRZdS4yPxBUDB/EA3MovNFGB3IQSqYPzNwBXKLDeYE2W7PBiqY9EvJMgGTQa7AyUGqG0Iz5AAOpUJEB64AbgG/ZvJZgYPl7gRUIbolmkUj5Sm/JzCLusGW4TOYRaNgG94JLJwZ3GK5kbKBVOBSQcDBLtbcEEuJGdwSk4NUsHASG2iASWdQUC0UDLhCcouNPOkMClEFS4AZ/FRBB3WMNHZhu1hDFktaSgZ2sboag414peJkY048ETtBs9mwz4TQqNlSs6Vmo2azLJ2phEbZif26aGVPYmSJmYORTVOORlbe89mkw5lhIh3PjEaUGjWblfZMlo6Vms3GZyZrSTlNRJUghEamTBOZso0VWDvKxcj6UTbvp5aZZSKq3oP5XMlUwvv73c6778+Xy+FgzXfVjrVJP+8vh/PL7tv59XS62/2zP71OF/153p+nz5f9Rc+q5uH8oJ8q+Hg8HYze75a7Q//WiCh+e0QCahJCVxpxoBEAXEInf1GAKwXoKyQJpSokibkp5Os4sK/AyQpoUuCUU09hGIWIR6Fz34uCbo4i/90oiNtccHcueKBAxaOIGbHng/QVhKy1TwqiYjdGoVXVi2KU15CtUcwSkBm7eT1Iy4JEVaPojqAbyCAvBYJLCAD3JL4QSbdCBxoM0YucYRUIfQgkjyaVpE2q0K0SOfDNEqvE+IpE5tIkZJsX2Rr/LFHCNi9KbIEUzD0JGGSn7g1amaWwlFnka4lBdiKye6HrwEqiXEukvgQIe3ZiWI3FR4lB39S1vlAr97Cakw+hfHpAczc/R4UWl+RSLkv7hetCg0H3ZP3zSmOW7ryOJCT6cqr7yY0SGJtEwm0SrQWzrMbiCxK69/VAJPSLdexFW4xUohsIplEHzs0L6Nf7ZyVwVWlfkcDYAkHsS5TBasToTbwwdVcjHAxnyeAZXnLurkYooypJgkuVQN6ypOkPiGXHOBjRNN6vtdVZuYSNIpKW1hNlq8gyJAHyJhHd84Rl/xlwm0iElUiSjSK5LCK8MZwoqy1c3BgOxGVhAIxburr+RE1LrvVL7/MaKW3SKJSbRmHYpoG00sDbNWTbmBZZNPRJS0+DaLRSSmkrZX/NH0oI5GWZo67EoKnqo0iPBJjjNi9KWFZK2CKhK2Vsy1zpBvI/07qkKPfrbRxJ2xqztrSNkaRlwQ4bJVbbhnizBG70opWJhIQ3z+qqaXxJoj0Q0MTYGEgqvdz6oUf7++Pl6iXAu2ldjvtfp0M9fHw936/Ovvz77Gf8JcLz5en+8PB6OZjS8iZB/33Xtwh3+r7ghz73siN1BjLpkT5M/K4rzZ3+prVzdmnUp+kRwQ6na/VXlv7g/fFujv4H","brillig_names":["get_4_slots_at_index"]},{"name":"get_4_slots_latest_index","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"feed_id","type":{"kind":"field"},"visibility":"private"},{"name":"start_slot","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6648186864564046035":{"error_kind":"string","string":"Function get_4_slots_latest_index can only be called statically"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13265554733035650515":{"error_kind":"string","string":"BigNum::validate_gt check fails"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIDbJwAABAMnAgMEAicCBAQAHwoAAwAEgNUuCIDVAAEuCIDWAAIlAAAAcyUAAAwqACIBAgIoAgADBIDXJwIEBAQuAgACgAMuAgADgAQuAgAEgAUlAAAWTCgCAAIEgNcnAgMEBDsOAAMAAigAgEMEACwrAIBEAP/u7u7u7u7u7u7u7u7u7u8rAIBFBgAIAAAAAAAAAAAAAAAAAAAoAIBGAAACKQCARwYAAQAAKACASAYAAC4AAAGASSgAgEoEAAQBAAABgEoAASgBgEkEAAEBAIBJAAKASi4AgEqASy4EgEeASwEAgEsAAoBLLgSASIBLAQCASwACgEsuBIBIgEsoAIBKAQAAKwCASwYBAAAAAAAAAAAAAAAAAAAALACATAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAACgAgE0AIAArAIBOBgCAAAAAAAAAAAAAAAAAAAAoAIBPBAABKACAUAQADigAgFEEAAIoAIBSBAAPKACAUwQAGigAgFQEABQoAIBVBAADKACAVgQAECgAgFcEAEQoAIBYBABQKACAWQQAGygAgFoEABUoAIBbBAA4KACAXAQAMigAgF0EAAQoAIBeBAARKACAXwQAQSgAgGAEAGAoAIBhBABFKACAYgQAUSgAgGMEAGkoAIBkBABjKACAZQQAHCgAgGYEABYoAIBnBABWKACAaAQAWigAgGkEADkoAIBqBAAzKACAawQASCgAgGwEACooAIBtBAAFKACAbgQAfigAgG8EABIoAIBwBABCKACAcQQAMCgAgHIEAF4oAIBzBABhKACAdAQAVCgAgHUEAEYoAIB2BAB8KACAdwQAUigAgHgEAHooAIB5BABqKACAegQAZCgAgHsEAHIoAIB8BABsKACAfQQAHSgAgH4EABcoAIB/BABNKACAgAQAZigAgIEEAFcoAICCBABbKACAgwQAdygAgIQEAHQoAICFBAA6KACAhgQANCgAgIcEAD0oAICIBABuKACAiQQASSgAgIoEACUoAICLBAArKACAjAQAHygAgI0EAAYoAICOBAB/KACAjwQADSgAgJAEABkoAICRBAATKACAkgQAQygAgJMEAE8oAICUBAA3KACAlQQAMSgAgJYEAEAoAICXBABfKACAmAQAaCgAgJkEAGIoAICaBABVKACAmwQAWSgAgJwEAEcoAICdBAApKACAngQAfSgAgJ8EAC8oAICgBABdKACAoQQAUygAgKIEAHsoAICjBAB5KACApAQAcSgAgKUEAGsoAICmBABMKACApwQAZSgAgKgEAHYoAICpBABzKACAqgQAPCgAgKsEAG0oAICsBAAkKACArQQAHigAgK4EAAwoAICvBAAYKACAsAQATigAgLEEADYoAICyBAA/KACAswQAZygAgLQEAFgoAIC1BAAoKACAtgQALigAgLcEAFwoAIC4BAB4KACAuQQAcCgAgLoEAEsoAIC7BAB1KACAvAQAOygAgL0EACMoAIC+BAALKACAvwQANSgAgMAEAD4oAIDBBAAnKACAwgQALSgAgMMEAG8oAIDEBABKKACAxQQAIigAgMYEAAooAIDHBAAmKACAyAQAISgAgMkEAAkoAIDKBAAgKACAywQACCgAgMwEAAcoAIDNBACALgAAAYDOKACAzwQAgQEAAAGAzwABKAGAzgQAAQEAgM4AAoDPLgCAz4DQLgSAT4DQAQCA0AACgNAuBIBQgNABAIDQAAKA0C4EgFGA0AEAgNAAAoDQLgSAUoDQAQCA0AACgNAuBIBTgNABAIDQAAKA0C4EgFSA0AEAgNAAAoDQLgSAVYDQAQCA0AACgNAuBIBWgNABAIDQAAKA0C4EgFeA0AEAgNAAAoDQLgSAWIDQAQCA0AACgNAuBIBZgNABAIDQAAKA0C4EgFqA0AEAgNAAAoDQLgSAW4DQAQCA0AACgNAuBIBcgNABAIDQAAKA0C4EgF2A0AEAgNAAAoDQLgSAXoDQAQCA0AACgNAuBIBfgNABAIDQAAKA0C4EgGCA0AEAgNAAAoDQLgSAYYDQAQCA0AACgNAuBIBigNABAIDQAAKA0C4EgGOA0AEAgNAAAoDQLgSAZIDQAQCA0AACgNAuBIBlgNABAIDQAAKA0C4EgGaA0AEAgNAAAoDQLgSAZ4DQAQCA0AACgNAuBIBogNABAIDQAAKA0C4EgGmA0AEAgNAAAoDQLgSAaoDQAQCA0AACgNAuBIBrgNABAIDQAAKA0C4EgGyA0AEAgNAAAoDQLgSAbYDQAQCA0AACgNAuBIBugNABAIDQAAKA0C4EgG+A0AEAgNAAAoDQLgSAcIDQAQCA0AACgNAuBIBxgNABAIDQAAKA0C4EgHKA0AEAgNAAAoDQLgSAc4DQAQCA0AACgNAuBIB0gNABAIDQAAKA0C4EgHWA0AEAgNAAAoDQLgSAdoDQAQCA0AACgNAuBIB3gNABAIDQAAKA0C4EgHiA0AEAgNAAAoDQLgSAeYDQAQCA0AACgNAuBIB6gNABAIDQAAKA0C4EgHuA0AEAgNAAAoDQLgSAfIDQAQCA0AACgNAuBIB9gNABAIDQAAKA0C4EgH6A0AEAgNAAAoDQLgSAf4DQAQCA0AACgNAuBICAgNABAIDQAAKA0C4EgIGA0AEAgNAAAoDQLgSAgoDQAQCA0AACgNAuBICDgNABAIDQAAKA0C4EgISA0AEAgNAAAoDQLgSAhYDQAQCA0AACgNAuBICGgNABAIDQAAKA0C4EgIeA0AEAgNAAAoDQLgSAiIDQAQCA0AACgNAuBICJgNABAIDQAAKA0C4EgIqA0AEAgNAAAoDQLgSAi4DQAQCA0AACgNAuBICMgNABAIDQAAKA0C4EgI2A0AEAgNAAAoDQLgSAjoDQAQCA0AACgNAuBICPgNABAIDQAAKA0C4EgJCA0AEAgNAAAoDQLgSAkYDQAQCA0AACgNAuBICSgNABAIDQAAKA0C4EgJOA0AEAgNAAAoDQLgSAlIDQAQCA0AACgNAuBICVgNABAIDQAAKA0C4EgJaA0AEAgNAAAoDQLgSAl4DQAQCA0AACgNAuBICYgNABAIDQAAKA0C4EgJmA0AEAgNAAAoDQLgSAmoDQAQCA0AACgNAuBICbgNABAIDQAAKA0C4EgJyA0AEAgNAAAoDQLgSAnYDQAQCA0AACgNAuBICegNABAIDQAAKA0C4EgJ+A0AEAgNAAAoDQLgSAoIDQAQCA0AACgNAuBIChgNABAIDQAAKA0C4EgKKA0AEAgNAAAoDQLgSAo4DQAQCA0AACgNAuBICkgNABAIDQAAKA0C4EgKWA0AEAgNAAAoDQLgSApoDQAQCA0AACgNAuBICngNABAIDQAAKA0C4EgKiA0AEAgNAAAoDQLgSAqYDQAQCA0AACgNAuBICqgNABAIDQAAKA0C4EgKuA0AEAgNAAAoDQLgSArIDQAQCA0AACgNAuBICtgNABAIDQAAKA0C4EgK6A0AEAgNAAAoDQLgSAr4DQAQCA0AACgNAuBICwgNABAIDQAAKA0C4EgLGA0AEAgNAAAoDQLgSAsoDQAQCA0AACgNAuBICzgNABAIDQAAKA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Si4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAjGSgBgAUEAAEDAIAGAAKABiMAACNeJiUAABaSASIAAYBPAAMtCwMCHAoCAwAcCgMCACsCAAQAAP///////////////////w4qAgQFJAIABQAAI6ElAAArAQEiAAGAUQADLQsDAhwKAgMAHAoDAgArAgAEAAD///////////////////8OKgIEBSQCAAUAACPeJQAAKwEBIgABgFUAAy0LAwIcCgIBABwKAQIAKQIAAwAAAf//DioCAwQkAgAEAAAkDyUAACsBJioBAAEFuBi3vusXfdM8BAIBJiUAABaSJwIFBAYtCAAGLQoBBwAIAAUAJQAAFvItAgAALQoHAy0KCAQcCgIFBhwKBQEAHAoBBQYoAgABBiAADCoFAQYkAgAGAAAkdicCAQQAPAYBAQUiAASATQABASiATAABAAQAKgQCAScCBAQFLQgABS4IgEYABi0KAwcACAAEACUAABjNLQIAAC0KBgIEKgECAy0KAwEmKgEAAQXFa8RaDhAAAjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKACABgQAAgcAgASABoAFLgCABIAIKACACQQAAA0AgAmABYAKFwCACoAKJACACgAAJV0DAIAIAAKACAEAgAOACYALLgGAC4AGAQCAA4AIgAsuAYALgAcBAIADgAmACy4EgAeACwEAgAOACIALLgSABoALAQCACQACgAkjAAAk+iYlAAAWki0IAQMAAAECAS4MgM8AAy4IgM8AAiMAACV9DSIAAoBVAAQkAgAEAAAlkiMAACduAyiAUQACAAQPIgACgFEABSQCAAUAACWvJQAAF6MNIgAEgFUABSQCAAUAACXEJQAAJLoAIgECBgAqBgQHLQsHBQ0ogEgABQAGJAIABgAAJfgjAAAl5wEiAAKATwAELQoEAiMAACV9BSiAuAAEAAInAgcEAAoqBwQGJAIABgAAJiwGKgIECQsiAAmAuAAIJAIACAAAJiwlAAAXkQsiAAWASAAEJAIABAAAJ0MjAAAmQRsiAAWA0QAEEioFBAYnAgQCAhoqBgQFEioGBQQnAgUCBBoqBAUGEioEBgUnAgQCCBoqBQQGEioFBgQnAgUCEBoqBAUGEioEBgUnAgQCIBoqBQQGEioFBgQnAgUCQBoqBAUGEioEBgUcCgUEACsCAAUAAfwQwvvPRxuROxTNJZXW1QQqBAUGHAoGBQYcCgUEABwKBAUGJwIEAnkaKgUEBhwKBgQAHAoEBQApAgAHAP////8OKgUHCCQCAAgAACcFJQAAKwEcCgYFBBwKBQQGHAoEBQQNIgAFgM0ABCQCAAQAACcpJQAAJLoBIIDOAAIABgAqBgUHLQsHBC0KBAEjAAAnTi4IgM8AASMAACdOACoCAQQOKgIEBSQCAAUAACdlJQAAF38tDgQDIwAAJ24tCwMBJiUAABaSLQgBBCcCBQQEAAgBBQEnAwQEAQAiBAIFLQoFBi4MgEgABgAiBgIGLgyASAAGACIGAgYuDIBIAAYtCAEFAAABAgEHIgACgLgABgciAAKAuAAIBSIACIC4AAkCKgIJBxwKBwgCHAoIAgQcCgIHAgMogNQABwACDyIAB4DUAAgkAgAIAAAoAiUAABejASIAAYBPAAktCwkIGioIAgktCAEKAAABAgEtDgkKGCoIBwknAggCgAwqBwgLJAIACwAAKDwlAAArEysCAAsGAQAAAAAAAAAAAAAAAAAAAAYqCQsMBCoMCw0CKgkNCA0iAAaAVQAJJAIACQAAKHUlAAAkui4CAASAAygAgAQEAAQlAAAi0S4IgAUACQAiCQILACoLBgwtDggMLQ4JBQMogFUABgAEDyIABoBVAAgkAgAIAAAovCUAABejLgiATwADIwAAKMcMKgMECCQCAAgAACjeIwAAKNktCwUBJg0iAAOAVQAIJAIACAAAKPMlAAAkugAiAQIJACoJAwstCwsIGCoIBwktCwoLACoJCwwOKgkMDSQCAA0AACkhJQAAF38rAgALBgEAAAAAAAAAAAAAAAAAAAAGKgwLDQQqDQsOAioMDgkAKgMGCw4qAwsMJAIADAAAKVwlAAAXfy0LBQwNIgALgFUADSQCAA0AACl1JQAAJLouAgAMgAMoAIAEBAAEJQAAItEuCIAFAA0AIg0CDgAqDgsPLQ4JDy0ODQUaKggCCS0OCQoBIgADgE8ACC0KCAMjAAAoxyUAABaSLQgBAwAAAQIBASIAAYBVAAUtCwUEGyIABIDRAAUuAgABgAMoAIAEBAAEJQAAItEuCIAFAAYAIgYCBwEiAAeAUQAILQ4FCC0OBgMcCgQFARwKBQEGJwIEAncYKgEEBS0IAQEAAAECAS0OBQEuCIBPAAIjAAAqNA0iAAKAVQAFJAIABQAAKk4jAAAqSS0LAwEmLQsDBQMogFEAAgAGDyIAAoBRAAckAgAHAAAqbyUAABejDSIABoBVAAckAgAHAAAqhCUAACS6ACIFAggAKggGCS0LCQcbIgAHgNEACC0LAQkAKggJCg4qCAoLJAIACwAAKrUlAAAXfy4CAAWAAygAgAQEAAQlAAAi0S4IgAUACAAiCAIJACoJBgstDgoLLQ4IAxgqBwQFESIABYBOAAYtDgYBASIAAoBPAAUtCgUCIwAAKjQqAQABBVoC5Bu1HqmfPAQCASYqAQABBclvkzsTnekWPAQCASY=","debug_symbols":"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","brillig_names":["get_4_slots_latest_index"]},{"name":"get_8_slots_at_index","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"feed_id","type":{"kind":"field"},"visibility":"private"},{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"start_slot","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":8,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"9193659048968351337":{"error_kind":"string","string":"Function get_8_slots_at_index can only be called statically"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZndTiM9DIbvpcc9SGznx9wKQqhAWVWqCurCJ31C3PvaM3FmipQspFoO6DOemXdsx3HS6cfmaf/w/uv+cHp++b25uf3YPJwPx+Ph1/3x5XH3dng5ifVj4/QfgHzQVj7D5ibJJ8qxdwpZwAtQLBC8gF4b1BIEIhVIYJAEVCeDQSzAzoAMeAZ0ZJALeL09K6ggCwAYiAXEQ0RxGcQxJGdQLVwgoEEqEMHALMkb6O1RIKugupFzAUYDvUvcIOcNYgFvFm8WMItmdwYugGSQCxAa2CMCGJhgNMFogskZmGCyR2QTzPYINkEugsGiCE4EUbIavDMwi7qKkp+g/iAoiIeIAppMDAqpgCZzhmDABTIZmEWzOoPeLpmPTgTJKYjPKMUWtRIm0EqdIcxuRPQGuYDmcAYuEMjALNGumXwWyCjZIAXyBmbRmidUiAV0CIgUYgENmSSKrOmdIc3ADgzUIgGyZnUCQINcAPXipJAKkFmCMwgGEg7JBGGdg8QKYgmSOtZKmMEsmvkgI8jsDeIM3jmqxEZefAugpBUccCI9S0paDyFOlI008YX0uqykqS9UbZr8QtkoVVuqtlxt2Wxea7VQNNLqKFSvI30uK2l5RjeR3BE1Np+indVZHmEiyWrUKL02qUJmA4eVspGvNs1QIX2GZgi0MAtVmzapGCZSZc0VaHeKaSJVVu9h8lT9A62ryXtQn2eafHafn9uN9fL7t/N+r6181dyl5b/uzvvT2+bm9H48bjf/7Y7v00W/X3en6fNtd5azork/PcmnCD4fjnulz+1yt2vf6hHZbvcYIFQJDhcavqPhAEzCESwKcKEAbQWSmVUUiH2sCvEyDmwrZNJpNCnItKeWQjcKZotC6qYVRbg6ivhvowi5jkVujkXuKIRkUfiI2PKB2woctMFPCixiV0YhM7IVRa+uZQZ6k4CYsVnXnbJMGELRSLK/aAbSqUsGZxIMkFsSP4ikOUM7Gol1WZ4DYV5GJHwJJPYGNXAdVA7XSsjO4GqJVWH8RCLmVCV4zIsYLZ2c3JgXyddAEsaWBHSqkzHXaUZuGVSfLyU61YmYzQtZB1YS6VKC2hLA2aoT3SoXXyU6fVN2AinU6e5WY/IllG8nNDbrszfR/FJcwmlpv3A50aDTPbP8WQfPmZvj2pNgb8up7EUHJdBXCcIxidqCZSNMIxLsaiCyhYYxL+piJBLNQJB6HThWL6A9378rgS4NSaCvgSC2JVKniWe0nVqSbzTNTVInnSmCVXiKsbkaIfdmCTEuswTiyJLm5FVD3aV0Mkr9/VpdnYWTGxRhWlqP51GRJSUO4pCI7Hncsv90OCbiYSVCPCgS0yKSB8PxvNrC+cFwwC8Lg3wfG+nqDoGWWmtPve9rEA1ppBCrRsowpoFhpYHXa/BYThMvGtk1V9sQeislp7pSttf8rgRDXJa50JToNFV5sWmRQM5+zIvklpUSRiRkpfR1mUvNQP4yrEuJ5vZ860dSt8ZZWtpgJLQs2G5QYrVt8FdL4KAXdZqwI7x6VFdN40cS9YWAFMZgIJRatXUnR7vHw/niJ4VP1Tofdg/HfTl8fj89rs6+/f9qZ+wnidfzy+P+6f28V6Xldwn5dwvyihkC3cl7Lz0SVyGhHMlLs1t5i7b1OJ3TS+UF1NaT08Pp2kRybbz7VEf/AA==","brillig_names":["get_8_slots_at_index"]},{"name":"get_8_slots_latest_index","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"feed_id","type":{"kind":"field"},"visibility":"private"},{"name":"start_slot","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":8,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13265554733035650515":{"error_kind":"string","string":"BigNum::validate_gt check fails"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17263930005548814647":{"error_kind":"string","string":"Function get_8_slots_latest_index can only be called statically"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIDfJwAABAMnAgMEAicCBAQAHwoAAwAEgNUuCIDVAAEuCIDWAAIlAAAAcyUAAAwqACIBAgIoAgADBIDXJwIEBAguAgACgAMuAgADgAQuAgAEgAUlAAAWcCgCAAIEgNcnAgMECDsOAAMAAigAgEMEACwrAIBEAP/u7u7u7u7u7u7u7u7u7u8rAIBFBgAIAAAAAAAAAAAAAAAAAAAoAIBGAAACKQCARwYAAQAAKACASAYAAC4AAAGASSgAgEoEAAQBAAABgEoAASgBgEkEAAEBAIBJAAKASi4AgEqASy4EgEeASwEAgEsAAoBLLgSASIBLAQCASwACgEsuBIBIgEsoAIBKAQAAKwCASwYBAAAAAAAAAAAAAAAAAAAALACATAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAACgAgE0AIAArAIBOBgCAAAAAAAAAAAAAAAAAAAAoAIBPBAABKACAUAQADigAgFEEAAIoAIBSBAAPKACAUwQAGigAgFQEABQoAIBVBAADKACAVgQAECgAgFcEAEQoAIBYBABQKACAWQQAGygAgFoEABUoAIBbBAA4KACAXAQAMigAgF0EAAQoAIBeBAARKACAXwQAQSgAgGAEAGAoAIBhBABFKACAYgQAUSgAgGMEAGkoAIBkBABjKACAZQQAHCgAgGYEABYoAIBnBABWKACAaAQAWigAgGkEADkoAIBqBAAzKACAawQASCgAgGwEACooAIBtBAAFKACAbgQAfigAgG8EABIoAIBwBABCKACAcQQAMCgAgHIEAF4oAIBzBABhKACAdAQAVCgAgHUEAEYoAIB2BAB8KACAdwQAUigAgHgEAHooAIB5BABqKACAegQAZCgAgHsEAHIoAIB8BABsKACAfQQAHSgAgH4EABcoAIB/BABNKACAgAQAZigAgIEEAFcoAICCBABbKACAgwQAdygAgIQEAHQoAICFBAA6KACAhgQANCgAgIcEAD0oAICIBABuKACAiQQASSgAgIoEACUoAICLBAArKACAjAQAHygAgI0EAAYoAICOBAB/KACAjwQADSgAgJAEABkoAICRBAATKACAkgQAQygAgJMEAE8oAICUBAA3KACAlQQAMSgAgJYEAEAoAICXBABfKACAmAQAaCgAgJkEAGIoAICaBABVKACAmwQAWSgAgJwEAEcoAICdBAApKACAngQAfSgAgJ8EAC8oAICgBABdKACAoQQAUygAgKIEAHsoAICjBAB5KACApAQAcSgAgKUEAGsoAICmBABMKACApwQAZSgAgKgEAHYoAICpBABzKACAqgQAPCgAgKsEAG0oAICsBAAkKACArQQAHigAgK4EAAwoAICvBAAYKACAsAQATigAgLEEADYoAICyBAA/KACAswQAZygAgLQEAFgoAIC1BAAoKACAtgQALigAgLcEAFwoAIC4BAB4KACAuQQAcCgAgLoEAEsoAIC7BAB1KACAvAQAOygAgL0EACMoAIC+BAALKACAvwQANSgAgMAEAD4oAIDBBAAnKACAwgQALSgAgMMEAG8oAIDEBABKKACAxQQAIigAgMYEAAooAIDHBAAmKACAyAQAISgAgMkEAAkoAIDKBAAgKACAywQACCgAgMwEAAcoAIDNBACALgAAAYDOKACAzwQAgQEAAAGAzwABKAGAzgQAAQEAgM4AAoDPLgCAz4DQLgSAT4DQAQCA0AACgNAuBIBQgNABAIDQAAKA0C4EgFGA0AEAgNAAAoDQLgSAUoDQAQCA0AACgNAuBIBTgNABAIDQAAKA0C4EgFSA0AEAgNAAAoDQLgSAVYDQAQCA0AACgNAuBIBWgNABAIDQAAKA0C4EgFeA0AEAgNAAAoDQLgSAWIDQAQCA0AACgNAuBIBZgNABAIDQAAKA0C4EgFqA0AEAgNAAAoDQLgSAW4DQAQCA0AACgNAuBIBcgNABAIDQAAKA0C4EgF2A0AEAgNAAAoDQLgSAXoDQAQCA0AACgNAuBIBfgNABAIDQAAKA0C4EgGCA0AEAgNAAAoDQLgSAYYDQAQCA0AACgNAuBIBigNABAIDQAAKA0C4EgGOA0AEAgNAAAoDQLgSAZIDQAQCA0AACgNAuBIBlgNABAIDQAAKA0C4EgGaA0AEAgNAAAoDQLgSAZ4DQAQCA0AACgNAuBIBogNABAIDQAAKA0C4EgGmA0AEAgNAAAoDQLgSAaoDQAQCA0AACgNAuBIBrgNABAIDQAAKA0C4EgGyA0AEAgNAAAoDQLgSAbYDQAQCA0AACgNAuBIBugNABAIDQAAKA0C4EgG+A0AEAgNAAAoDQLgSAcIDQAQCA0AACgNAuBIBxgNABAIDQAAKA0C4EgHKA0AEAgNAAAoDQLgSAc4DQAQCA0AACgNAuBIB0gNABAIDQAAKA0C4EgHWA0AEAgNAAAoDQLgSAdoDQAQCA0AACgNAuBIB3gNABAIDQAAKA0C4EgHiA0AEAgNAAAoDQLgSAeYDQAQCA0AACgNAuBIB6gNABAIDQAAKA0C4EgHuA0AEAgNAAAoDQLgSAfIDQAQCA0AACgNAuBIB9gNABAIDQAAKA0C4EgH6A0AEAgNAAAoDQLgSAf4DQAQCA0AACgNAuBICAgNABAIDQAAKA0C4EgIGA0AEAgNAAAoDQLgSAgoDQAQCA0AACgNAuBICDgNABAIDQAAKA0C4EgISA0AEAgNAAAoDQLgSAhYDQAQCA0AACgNAuBICGgNABAIDQAAKA0C4EgIeA0AEAgNAAAoDQLgSAiIDQAQCA0AACgNAuBICJgNABAIDQAAKA0C4EgIqA0AEAgNAAAoDQLgSAi4DQAQCA0AACgNAuBICMgNABAIDQAAKA0C4EgI2A0AEAgNAAAoDQLgSAjoDQAQCA0AACgNAuBICPgNABAIDQAAKA0C4EgJCA0AEAgNAAAoDQLgSAkYDQAQCA0AACgNAuBICSgNABAIDQAAKA0C4EgJOA0AEAgNAAAoDQLgSAlIDQAQCA0AACgNAuBICVgNABAIDQAAKA0C4EgJaA0AEAgNAAAoDQLgSAl4DQAQCA0AACgNAuBICYgNABAIDQAAKA0C4EgJmA0AEAgNAAAoDQLgSAmoDQAQCA0AACgNAuBICbgNABAIDQAAKA0C4EgJyA0AEAgNAAAoDQLgSAnYDQAQCA0AACgNAuBICegNABAIDQAAKA0C4EgJ+A0AEAgNAAAoDQLgSAoIDQAQCA0AACgNAuBIChgNABAIDQAAKA0C4EgKKA0AEAgNAAAoDQLgSAo4DQAQCA0AACgNAuBICkgNABAIDQAAKA0C4EgKWA0AEAgNAAAoDQLgSApoDQAQCA0AACgNAuBICngNABAIDQAAKA0C4EgKiA0AEAgNAAAoDQLgSAqYDQAQCA0AACgNAuBICqgNABAIDQAAKA0C4EgKuA0AEAgNAAAoDQLgSArIDQAQCA0AACgNAuBICtgNABAIDQAAKA0C4EgK6A0AEAgNAAAoDQLgSAr4DQAQCA0AACgNAuBICwgNABAIDQAAKA0C4EgLGA0AEAgNAAAoDQLgSAsoDQAQCA0AACgNAuBICzgNABAIDQAAKA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AQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAjbi4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAjPSgBgAUEAAEDAIAGAAKABiMAACOCJiUAABa2ASIAAYBPAAMtCwMCHAoCAwAcCgMCACsCAAQAAP///////////////////w4qAgQFJAIABQAAI8UlAAArJQEiAAGAUQADLQsDAhwKAgMAHAoDAgArAgAEAAD///////////////////8OKgIEBSQCAAUAACQCJQAAKyUBIgABgFUAAy0LAwIcCgIBABwKAQIAKQIAAwAAAf//DioCAwQkAgAEAAAkMyUAACslJioBAAEFuBi3vusXfdM8BAIBJiUAABa2JwIFBAYtCAAGLQoBBwAIAAUAJQAAFxYtAgAALQoHAy0KCAQcCgIFBhwKBQEAHAoBBQYoAgABBiAADCoFAQYkAgAGAAAkmicCAQQAPAYBAQUiAASATQABASiATAABAAQAKgQCAScCBAQFLQgABS4IgEYABi0KAwcACAAEACUAABjxLQIAAC0KBgIEKgECAy0KAwEmKgEAAQXFa8RaDhAAAjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKACABgQAAgcAgASABoAFLgCABIAIKACACQQAAA0AgAmABYAKFwCACoAKJACACgAAJYEDAIAIAAKACAEAgAOACYALLgGAC4AGAQCAA4AIgAsuAYALgAcBAIADgAmACy4EgAeACwEAgAOACIALLgSABoALAQCACQACgAkjAAAlHiYlAAAWti0IAQMAAAECAS4MgM8AAy4IgM8AAiMAACWhDSIAAoBVAAQkAgAEAAAltiMAACeSAyiAUQACAAQPIgACgFEABSQCAAUAACXTJQAAF8cNIgAEgFUABSQCAAUAACXoJQAAJN4AIgECBgAqBgQHLQsHBQ0ogEgABQAGJAIABgAAJhwjAAAmCwEiAAKATwAELQoEAiMAACWhBSiAuAAEAAInAgcEAAoqBwQGJAIABgAAJlAGKgIECQsiAAmAuAAIJAIACAAAJlAlAAAXtQsiAAWASAAEJAIABAAAJ2cjAAAmZRsiAAWA0QAEEioFBAYnAgQCAhoqBgQFEioGBQQnAgUCBBoqBAUGEioEBgUnAgQCCBoqBQQGEioFBgQnAgUCEBoqBAUGEioEBgUnAgQCIBoqBQQGEioFBgQnAgUCQBoqBAUGEioEBgUcCgUEACsCAAUAAfwQwvvPRxuROxTNJZXW1QQqBAUGHAoGBQYcCgUEABwKBAUGJwIEAnkaKgUEBhwKBgQAHAoEBQApAgAHAP////8OKgUHCCQCAAgAACcpJQAAKyUcCgYFBBwKBQQGHAoEBQQNIgAFgM0ABCQCAAQAACdNJQAAJN4BIIDOAAIABgAqBgUHLQsHBC0KBAEjAAAnci4IgM8AASMAACdyACoCAQQOKgIEBSQCAAUAACeJJQAAF6MtDgQDIwAAJ5ItCwMBJiUAABa2LQgBBCcCBQQEAAgBBQEnAwQEAQAiBAIFLQoFBi4MgEgABgAiBgIGLgyASAAGACIGAgYuDIBIAAYtCAEFAAABAgEHIgACgLgABgciAAKAuAAIBSIACIC4AAkCKgIJBxwKBwgCHAoIAgQcCgIHAgMogNQABwACDyIAB4DUAAgkAgAIAAAoJiUAABfHASIAAYBPAAktCwkIGioIAgktCAEKAAABAgEtDgkKGCoIBwknAggCgAwqBwgLJAIACwAAKGAlAAArNysCAAsGAQAAAAAAAAAAAAAAAAAAAAYqCQsMBCoMCw0CKgkNCA0iAAaAVQAJJAIACQAAKJklAAAk3i4CAASAAygAgAQEAAQlAAAi9S4IgAUACQAiCQILACoLBgwtDggMLQ4JBQMogFUABgAEDyIABoBVAAgkAgAIAAAo4CUAABfHLgiATwADIwAAKOsMKgMECCQCAAgAACkCIwAAKP0tCwUBJg0iAAOAVQAIJAIACAAAKRclAAAk3gAiAQIJACoJAwstCwsIGCoIBwktCwoLACoJCwwOKgkMDSQCAA0AAClFJQAAF6MrAgALBgEAAAAAAAAAAAAAAAAAAAAGKgwLDQQqDQsOAioMDgkAKgMGCw4qAwsMJAIADAAAKYAlAAAXoy0LBQwNIgALgFUADSQCAA0AACmZJQAAJN4uAgAMgAMoAIAEBAAEJQAAIvUuCIAFAA0AIg0CDgAqDgsPLQ4JDy0ODQUaKggCCS0OCQoBIgADgE8ACC0KCAMjAAAo6yUAABa2LQgBAwAAAQIBASIAAYBVAAUtCwUEGyIABIDRAAUuAgABgAMoAIAEBAAEJQAAIvUuCIAFAAYAIgYCBwEiAAeAUQAILQ4FCC0OBgMcCgQFARwKBQEGJwIEAncYKgEEBS0IAQEAAAECAS0OBQEuCIBPAAIjAAAqWA0iAAKAVQAFJAIABQAAKnIjAAAqbS0LAwEmLQsDBQMogFEAAgAGDyIAAoBRAAckAgAHAAAqkyUAABfHDSIABoBVAAckAgAHAAAqqCUAACTeACIFAggAKggGCS0LCQcbIgAHgNEACC0LAQkAKggJCg4qCAoLJAIACwAAKtklAAAXoy4CAAWAAygAgAQEAAQlAAAi9S4IgAUACAAiCAIJACoJBgstDgoLLQ4IAxgqBwQFESIABYBOAAYtDgYBASIAAoBPAAUtCgUCIwAAKlgqAQABBVoC5Bu1HqmfPAQCASYqAQABBclvkzsTnekWPAQCASY=","debug_symbols":"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","brillig_names":["get_8_slots_latest_index"]},{"name":"get_as_much_latest_sliced_data","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"feed_id","type":{"kind":"field"},"visibility":"private"},{"name":"start_slot","type":{"kind":"field"},"visibility":"private"},{"name":"slots","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":180,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"798537054514309283":{"error_kind":"string","string":"Function get_as_much_latest_sliced_data can only be called statically"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13265554733035650515":{"error_kind":"string","string":"BigNum::validate_gt check fails"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIGMJwAABAMnAgQEAycCBQQAHwoABAAFgNUuCIDVAAEuCIDWAAIuCIDXAAMlAAAAeSUAAAwwACIBAgIoAgADBIDYJwIEBLQuAgACgAMuAgADgAQuAgAEgAUlAAAWdSgCAAIEgNgnAgMEtDsOAAMAAigAgEMEACwrAIBEAP/u7u7u7u7u7u7u7u7u7u8rAIBFBgAIAAAAAAAAAAAAAAAAAAAoAIBGAAACKQCARwYAAQAAKACASAYAAC4AAAGASSgAgEoEAAQBAAABgEoAASgBgEkEAAEBAIBJAAKASi4AgEqASy4EgEeASwEAgEsAAoBLLgSASIBLAQCASwACgEsuBIBIgEsoAIBKAQAAKwCASwYBAAAAAAAAAAAAAAAAAAAALACATAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAACgAgE0AIAArAIBOBgCAAAAAAAAAAAAAAAAAAAAoAIBPBAABKACAUAQADigAgFEEAAIoAIBSBAAPKACAUwQAGigAgFQEABQoAIBVBAADKACAVgQAECgAgFcEAEQoAIBYBABQKACAWQQAGygAgFoEABUoAIBbBAA4KACAXAQAMigAgF0EAAQoAIBeBAARKACAXwQAQSgAgGAEAGAoAIBhBABFKACAYgQAUSgAgGMEAGkoAIBkBABjKACAZQQAHCgAgGYEABYoAIBnBABWKACAaAQAWigAgGkEADkoAIBqBAAzKACAawQASCgAgGwEACooAIBtBAAFKACAbgQAfigAgG8EABIoAIBwBABCKACAcQQAMCgAgHIEAF4oAIBzBABhKACAdAQAVCgAgHUEAEYoAIB2BAB8KACAdwQAUigAgHgEAHooAIB5BABqKACAegQAZCgAgHsEAHIoAIB8BABsKACAfQQAHSgAgH4EABcoAIB/BABNKACAgAQAZigAgIEEAFcoAICCBABbKACAgwQAdygAgIQEAHQoAICFBAA6KACAhgQANCgAgIcEAD0oAICIBABuKACAiQQASSgAgIoEACUoAICLBAArKACAjAQAHygAgI0EAAYoAICOBAB/KACAjwQADSgAgJAEABkoAICRBAATKACAkgQAQygAgJMEAE8oAICUBAA3KACAlQQAMSgAgJYEAEAoAICXBABfKACAmAQAaCgAgJkEAGIoAICaBABVKACAmwQAWSgAgJwEAEcoAICdBAApKACAngQAfSgAgJ8EAC8oAICgBABdKACAoQQAUygAgKIEAHsoAICjBAB5KACApAQAcSgAgKUEAGsoAICmBABMKACApwQAZSgAgKgEAHYoAICpBABzKACAqgQAPCgAgKsEAG0oAICsBAAkKACArQQAHigAgK4EAAwoAICvBAAYKACAsAQATigAgLEEADYoAICyBAA/KACAswQAZygAgLQEAFgoAIC1BAAoKACAtgQALigAgLcEAFwoAIC4BAB4KACAuQQAcCgAgLoEAEsoAIC7BAB1KACAvAQAOygAgL0EACMoAIC+BAALKACAvwQANSgAgMAEAD4oAIDBBAAnKACAwgQALSgAgMMEAG8oAIDEBABKKACAxQQAIigAgMYEAAooAIDHBAAmKACAyAQAISgAgMkEAAkoAIDKBAAgKACAywQACCgAgMwEAAcoAIDNBACALgAAAYDOKACAzwQAgQEAAAGAzwABKAGAzgQAAQEAgM4AAoDPLgCAz4DQLgSAT4DQAQCA0AACgNAuBIBQgNABAIDQAAKA0C4EgFGA0AEAgNAAAoDQLgSAUoDQAQCA0AACgNAuBIBTgNABAIDQAAKA0C4EgFSA0AEAgNAAAoDQLgSAVYDQAQCA0AACgNAuBIBWgNABAIDQAAKA0C4EgFeA0AEAgNAAAoDQLgSAWIDQAQCA0AACgNAuBIBZgNABAIDQAAKA0C4EgFqA0AEAgNAAAoDQLgSAW4DQAQCA0AACgNAuBIBcgNABAIDQAAKA0C4EgF2A0AEAgNAAAoDQLgSAXoDQAQCA0AACgNAuBIBfgNABAIDQAAKA0C4EgGCA0AEAgNAAAoDQLgSAYYDQAQCA0AACgNAuBIBigNABAIDQAAKA0C4EgGOA0AEAgNAAAoDQLgSAZIDQAQCA0AACgNAuBIBlgNABAIDQAAKA0C4EgGaA0AEAgNAAAoDQLgSAZ4DQAQCA0AACgNAuBIBogNABAIDQAAKA0C4EgGmA0AEAgNAAAoDQLgSAaoDQAQCA0AACgNAuBIBrgNABAIDQAAKA0C4EgGyA0AEAgNAAAoDQLgSAbYDQAQCA0AACgNAuBIBugNABAIDQAAKA0C4EgG+A0AEAgNAAAoDQLgSAcIDQAQCA0AACgNAuBIBxgNABAIDQAAKA0C4EgHKA0AEAgNAAAoDQLgSAc4DQAQCA0AACgNAuBIB0gNABAIDQAAKA0C4EgHWA0AEAgNAAAoDQLgSAdoDQAQCA0AACgNAuBIB3gNABAIDQAAKA0C4EgHiA0AEAgNAAAoDQLgSAeYDQAQCA0AACgNAuBIB6gNABAIDQAAKA0C4EgHuA0AEAgNAAAoDQLgSAfIDQAQCA0AACgNAuBIB9gNABAIDQAAKA0C4EgH6A0AEAgNAAAoDQLgSAf4DQAQCA0AACgNAuBICAgNABAIDQAAKA0C4EgIGA0AEAgNAAAoDQLgSAgoDQAQCA0AACgNAuBICDgNABAIDQAAKA0C4EgISA0AEAgNAAAoDQLgSAhYDQAQCA0AACgNAuBICGgNABAIDQAAKA0C4EgIeA0AEAgNAAAoDQLgSAiIDQAQCA0AACgNAuBICJgNABAIDQAAKA0C4EgIqA0AEAgNAAAoDQLgSAi4DQAQCA0AACgNAuBICMgNABAIDQAAKA0C4EgI2A0AEAgNAAAoDQLgSAjoDQAQCA0AACgNAuBICPgNABAIDQAAKA0C4EgJCA0AEAgNAAAoDQLgSAkYDQAQCA0AACgNAuBICSgNABAIDQAAKA0C4EgJOA0AEAgNAAAoDQLgSAlIDQAQCA0AACgNAuBICVgNABAIDQAAKA0C4EgJaA0AEAgNAAAoDQLgSAl4DQAQCA0AACgNAuBICYgNABAIDQAAKA0C4EgJmA0AEAgNAAAoDQLgSAmoDQAQCA0AACgNAuBICbgNABAIDQAAKA0C4EgJyA0AEAgNAAAoDQLgSAnYDQAQCA0AACgNAuBICegNABAIDQAAKA0C4EgJ+A0AEAgNAAAoDQLgSAoIDQAQCA0AACgNAuBIChgNABAIDQAAKA0C4EgKKA0AEAgNAAAoDQLgSAo4DQAQCA0AACgNAuBICkgNABAIDQAAKA0C4EgKWA0AEAgNAAAoDQLgSApoDQAQCA0AACgNAuBICngNABAIDQAAKA0C4EgKiA0AEAgNAAAoDQLgSAqYDQAQCA0AACgNAuBICqgNABAIDQAAKA0C4EgKuA0AEAgNAAAoDQLgSArIDQAQCA0AACgNAuBICtgNABAIDQAAKA0C4EgK6A0AEAgNAAAoDQLgSAr4DQAQCA0AACgNAuBICwgNABAIDQAAKA0C4EgLGA0AEAgNAAAoDQLgSAsoDQAQCA0AACgNAuBICzgNAB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AAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAACNzLgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAACNCKAGABQQAAQMAgAYAAoAGIwAAI4cmJQAAFrsBIgABgE8AAy0LAwIcCgIDABwKAwIAKwIABAAA////////////////////DioCBAUkAgAFAAAjyiUAACsqASIAAYBRAAMtCwMCHAoCAwAcCgMCACsCAAQAAP///////////////////w4qAgQFJAIABQAAJAclAAArKgEiAAGAVQADLQsDAhwKAgEAHAoBAgApAgADAAAB//8OKgIDBCQCAAQAACQ4JQAAKyomKgEAAQW4GLe+6xd90zwEAgEmJQAAFrsnAgUEBi0IAAYtCgEHAAgABQAlAAAXGy0CAAAtCgcDLQoIBBwKAgUGHAoFAQAcCgEFBigCAAEGIAAMKgUBBiQCAAYAACSfJwIBBAA8BgEBBSIABIBNAAEBKIBMAAEABAAqBAIBJwIEBAUtCAAFLgiARgAGLQoDBwAIAAQAJQAAGPYtAgAALQoGAgQqAQIDLQoDASYqAQABBcVrxFoOEAACPAQCASYqAQABBb4eP/8+pPb6PAQCASYoAIAGBAACBwCABIAGgAUuAIAEgAgoAIAJBAAADQCACYAFgAoXAIAKgAokAIAKAAAlhgMAgAgAAoAIAQCAA4AJgAsuAYALgAYBAIADgAiACy4BgAuABwEAgAOACYALLgSAB4ALAQCAA4AIgAsuBIAGgAsBAIAJAAKACSMAACUjJiUAABa7LQgBAwAAAQIBLgyAzwADLgiAzwACIwAAJaYNIgACgFUABCQCAAQAACW7IwAAJ5cDKIBRAAIABA8iAAKAUQAFJAIABQAAJdglAAAXzA0iAASAVQAFJAIABQAAJe0lAAAk4wAiAQIGACoGBActCwcFDSiASAAFAAYkAgAGAAAmISMAACYQASIAAoBPAAQtCgQCIwAAJaYFKIC4AAQAAicCBwQACioHBAYkAgAGAAAmVQYqAgQJCyIACYC4AAgkAgAIAAAmVSUAABe6CyIABYBIAAQkAgAEAAAnbCMAACZqGyIABYDRAAQSKgUEBicCBAICGioGBAUSKgYFBCcCBQIEGioEBQYSKgQGBScCBAIIGioFBAYSKgUGBCcCBQIQGioEBQYSKgQGBScCBAIgGioFBAYSKgUGBCcCBQJAGioEBQYSKgQGBRwKBQQAKwIABQAB/BDC+89HG5E7FM0lldbVBCoEBQYcCgYFBhwKBQQAHAoEBQYnAgQCeRoqBQQGHAoGBAAcCgQFACkCAAcA/////w4qBQcIJAIACAAAJy4lAAArKhwKBgUEHAoFBAYcCgQFBA0iAAWAzQAEJAIABAAAJ1IlAAAk4wEggM4AAgAGACoGBQctCwcELQoEASMAACd3LgiAzwABIwAAJ3cAKgIBBA4qAgQFJAIABQAAJ44lAAAXqC0OBAMjAAAnly0LAwEmJQAAFrstCAEEJwIFBAQACAEFAScDBAQBACIEAgUtCgUGLgyASAAGACIGAgYuDIBIAAYAIgYCBi4MgEgABi0IAQUAAAECAQciAAKAuAAGByIAAoC4AAgFIgAIgLgACQIqAgkHHAoHCAIcCggCBBwKAgcCAyiA1AAHAAIPIgAHgNQACCQCAAgAACgrJQAAF8wBIgABgE8ACS0LCQgaKggCCS0IAQoAAAECAS0OCQoYKggHCScCCAKADCoHCAskAgALAAAoZSUAACs8KwIACwYBAAAAAAAAAAAAAAAAAAAABioJCwwEKgwLDQIqCQ0IDSIABoBVAAkkAgAJAAAoniUAACTjLgIABIADKACABAQABCUAACL6LgiABQAJACIJAgsAKgsGDC0OCAwtDgkFAyiAVQAGAAQPIgAGgFUACCQCAAgAACjlJQAAF8wuCIBPAAMjAAAo8AwqAwQIJAIACAAAKQcjAAApAi0LBQEmDSIAA4BVAAgkAgAIAAApHCUAACTjACIBAgkAKgkDCy0LCwgYKggHCS0LCgsAKgkLDA4qCQwNJAIADQAAKUolAAAXqCsCAAsGAQAAAAAAAAAAAAAAAAAAAAYqDAsNBCoNCw4CKgwOCQAqAwYLDioDCwwkAgAMAAAphSUAABeoLQsFDA0iAAuAVQANJAIADQAAKZ4lAAAk4y4CAAyAAygAgAQEAAQlAAAi+i4IgAUADQAiDQIOACoOCw8tDgkPLQ4NBRoqCAIJLQ4JCgEiAAOATwAILQoIAyMAACjwJQAAFrstCAEDAAABAgEBIgABgFUABS0LBQQbIgAEgNEABS4CAAGAAygAgAQEAAQlAAAi+i4IgAUABgAiBgIHASIAB4BRAAgtDgUILQ4GAxwKBAUBHAoFAQYnAgQCdxgqAQQFLQgBAQAAAQIBLQ4FAS4IgE8AAiMAACpdDSIAAoBVAAUkAgAFAAAqdyMAACpyLQsDASYtCwMFAyiAUQACAAYPIgACgFEAByQCAAcAACqYJQAAF8wNIgAGgFUAByQCAAcAACqtJQAAJOMAIgUCCAAqCAYJLQsJBxsiAAeA0QAILQsBCQAqCAkKDioICgskAgALAAAq3iUAABeoLgIABYADKACABAQABCUAACL6LgiABQAIACIIAgkAKgkGCy0OCgstDggDGCoHBAURIgAFgE4ABi0OBgEBIgACgE8ABS0KBQIjAAAqXSoBAAEFWgLkG7UeqZ88BAIBJioBAAEFyW+TOxOd6RY8BAIBJg==","debug_symbols":"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","brillig_names":["get_as_much_latest_sliced_data"]},{"name":"get_as_much_sliced_data_at_index","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"feed_id","type":{"kind":"field"},"visibility":"private"},{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"start_slot","type":{"kind":"field"},"visibility":"private"},{"name":"slots","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":180,"type":{"kind":"field"}},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"12925009078149006190":{"error_kind":"string","string":"Function get_as_much_sliced_data_at_index can only be called statically"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZnfTiM7DMbfpddcJM5f8yoIoQJlVakqqAtHOkK8+/E3EyftSsmBVLsXy2/cyTd2Yjvp9HPzvHv8+PWwP768/t7c3n1uHk/7w2H/6+Hw+rR9378exfq5MfiPKG5u/c2GnN3cJvyVa2sEvBewAoEUkgDujbAEgWQUcoHsBKCTcwEmhbiCM0YhFLBqsV4Bw7MAQZAF4CAZgOiQ+OPgIRGACwS1hFwArq4QCySroJZsFDAcT88QxNM5reANKcgoJ254+LxCKEBqIbU4tTi1eLXA+RW4QHAFolXQUUlHpWrRUVl1MOFOpsWzUyiWYGAhQC5g1eKoQMAjHACPkFUOEZYICApcIDmFVCCTglrYKmC4zGrEunsLwBxKtsRlDhcIBbDcK+TVn+h8AW8VYgFk5gqpQFRL1HtSiSs7cd4DMPMrqAVp4z2AC0RYAoALJFgknIxwALyEs4BaEI5PgFxgqS4AsncF3CyJxMiEFdSCBFghF0A4ngESYJBV5iSWYAGpQFYLZj7IUjJ7BV7BGpOULFUS34IDEQZ4ENIhhIUwIoEw74WiEmY+8EJJKVYbJn8lFFuhasvVlquN1SYPqcRKyI6VqN7n5bnRgJCe0S4kIyJisyiP9VM0pOgWklmNiNKiQgqpjZCTK1lbqdowQ4WgjBkiJGahavNQjgtBGXNFASoZhMKOvJCMSPCPkFeL97T4vNDis/36utlow354P+126NdnHVz6+tv2tDu+b26PH4fDzeaf7eFjuen32/a4/H3fnuRTec7u+Cx/RfBlf9iBvm7aaNMfap1jHW5doFAlOFxo2IGGQXNdJYynpkAXCtRX8GxSUfBsY1WIl3G4voIUfS4K2UffUxhGwaxRSN70oghXRxH/bhQh17XI3bXIAwXp+aoQnev5wH0F6XO+KLCIXRmFVGQvilFeU0SprRIUs+vm9SAtk0OrXDSSHCu6gQzyksmoBBPlnsQPIulW6EAjxaAVmpJtKxL+CCSOFjVwXVQO10pEk6ckoqUqQfZqL85y60de5FQleDIQ7CKrRDJzXiRbA0ku9iRolJ1yIlYJb1pe2Hwp4fsSTs7SRUK2kjOJdCkx6JvEWRNcvjpQV2IwF3KYSKF2DHO2Jn+E8u0Jjd0UH9WqbcklnFoHp8tapUH7zPJPN4GcubuuIwmuZZKZJiWcrRLezUnULp75bC5+IMGm1bvpF+vYi7qfiUQ3EBdGTTxWL6hf79+VcCZNSThbA3GuLzHY21N2ethLOXQ3NMejrYQ0w1OM3Q3ND6tEvsK2KqE4sysaSu3QOZhRT8MjX93ghZOZFGHfWo/lWZE2JYbilIgcm0w7who3J2LpTMTzpEhMTSRPhiPf3top0E6GQ7ZtDPISbKary7dm33KtX3rf1/B+SiOFWDVSpjkNF8403PUaPDeniZtGNt3dNoy+Lklvrztlf88fSjDFts2FrsSgqVKOGom8FLVzXiTTdkqakZCd0tZtLnUD+Z9lbSma+/U2jqQejbO0tMlIfNuwzaTE2bHBXi3hJr2oZcLGu6tX9axp/EiivlOQxJgMxKdebt3L1fZpf7r46eELWqf99vGwK5cvH8ens0/f/33TT/Sni7fT69Pu+eO0g1L7/UL+u5O2fSO/UtzLqzNcyTtNSlau5C3anbweuLFu+Qy3yvssucy4XO6VQ4K8gbv/gqP/AQ==","brillig_names":["get_as_much_sliced_data_at_index"]},{"name":"get_block_number","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"4704061078684901766":{"error_kind":"string","string":"Function get_block_number can only be called statically"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBFJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAARSUAAABGLgIAAYBEKAIAAgSARCcCAwQBOw4AAwACJiUAAACbHgIAAQAeAgACADMqAAEAAgADJwIBAQEkAgADAAAAbyUAAADEHgIAAQknAgIAAQoqAQIDJAIAAwAAAIslAAAA1icCAQAALwoAAQACLQoCASYoAIAEBHgADQAAAIAEgAMkAIADAAAAwyoBAAEF96Hzr6Wt1Mo8BAIBJioBAAEFvh4//z6k9vo8BAIBJioBAAEFQUguoLzBIYY8BAIBJg==","debug_symbols":"tZXdisIwEIXfJde9yGQy+fFVFpGqUQqlSm0XFum778RtrF1IYJG96ZxJzOecZpLexTHsx/Ou6U6Xm9h83MW+b9q2Oe/ay6EemkvHo3ch48OS2OhKOE4sB85AVsIjR+DofiJIMwsAFjqKOEIsFCSRRlAn4Vl4FjqO+GmqRKpgN/QhxAJeSuJCr3UfukFsurFtK/FZt+PjR7dr3T3iUPc8yxWG7siRgaemDVFN1bJa5pcCok/LAUnRE+FpxYACQyqVEFKrhaBWBJUnaC/tTNAezJNg1j4wT3Bau5ngtNE5QtGF98kF8OZkXNDbLsz/uiD33AuX3QtXIJBNLsAg5mrweYIn1DPBM+xNF6CyLkp9rYyBhFDGYbavC21pkWhmWLSQNVLoS69kQnilXA7xByfZE1pgkIR0yEnick3QLyOF1rQOE8I6yr8LW0AYlU6YNSb7LqDUnKA9PjuD1PqQbTmrD02/utenSOubet+GOT2N3eFldvi6ppn0Xbj2l0M4jn2IpOXjAPz8YA+ot/HG5wSpQrud4l9/Aw==","brillig_names":["get_block_number"]},{"name":"get_data_at_index","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"feed_id","type":{"kind":"field"},"visibility":"private"},{"name":"index","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5755000507507637366":{"error_kind":"string","string":"Function get_data_at_index can only be called statically"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIBKJwAABAMnAgMEAicCBAQAHwoAAwAEgEcuCIBHAAEuCIBIAAIlAAAAUSUAAACaLgIAAYBJKAIAAgSASScCAwQBOw4AAwACLACAQwAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAACgAgEQAIAAoAIBFAAACKwCARgYACAAAAAAAAAAAAAAAAAAAJiUAAAKpHgIABAAeAgAFADMqAAQABQAGJwIEAQEkAgAGAAAAwyUAAALSHgIABQknAgYAAQoqBQYHJAIABwAAAN8lAAAC5BwKAQcGHAoHBQAcCgUBBicCBQJ4GioBBQccCgcIAhwKCAUGKwIACAYBAAAAAAAAAAAAAAAAAAAABioBCAkEKgkICgIqAQoHDSIAB4BGAAEkAgABAAABPycCCAQAPAYIAScCAQYgDCoFAQgkAgAIAAABWicCAQQAPAYBARwKBQEAHAoHBQAcCgIIBhwKCAcAHAoHCAYoAgAHBiAADCoIBwkkAgAJAAABkCcCBwQAPAYHAQUiAAWARAAHASiAQwAHAAUAKgUCBy0IAQIAAAECAS0OBgInAggEAicCCQEBLQgBBScCCgQhAAgBCgEnAwUEAQAiBQIKJwILBCBDA6oAAQAIAAsACQAKJwIMBCAuAgAKgAMuAgAMgAQlAAAC9icCAQQBJwIIBCEnAgkEIC0KAQMjAAACFAwqAwgKJAIACgAAAjYjAAACJi0LAgEEKgcBAi8KAAIAASYtCwIKBCoKCgsCKgkDCg4qAwkMJAIADAAAAlYlAAADdgwqCgkMJAIADAAAAmglAAADiAAiBQINACoNCg4tCw4MHAoMCgAFIgALgEUADAQqCgwNAioGCgwEKgwLCgAqDQoLLQ4LAgAqAwEKLQoKAyMAAAIUKACABAR4AA0AAACABIADJACAAwAAAtEqAQABBfeh86+lrdTKPAQCASYqAQABBb4eP/8+pPb6PAQCASYqAQABBU/d3nhkL3x2PAQCASYoAIAGBAACBwCABIAGgAUuAIAEgAgoAIAJBAAADQCACYAFgAoXAIAKgAokAIAKAAADdQMAgAgAAoAIAQCAA4AJgAsuAYALgAYBAIADgAiACy4BgAuABwEAgAOACYALLgSAB4ALAQCAA4AIgAsuBIAGgAsBAIAJAAKACSMAAAMSJioBAAEFKIaSsEfc/UM8BAIBJioBAAEFxWvEWg4QAAI8BAIBJg==","debug_symbols":"tZjbTuNADIbfJde9mPFpZniVFUIFAqpUFVTalVao7752Mk7KSpNdAntDvziTP7Zje0Leu8f+/vx8tzs8vbx1Nz/eu/vjbr/fPd/tXx62p93LQa3vXbA/kUt3Q5suCnU3yX71OAaFlBSiQoYKJTiwgl4EwSxswBWiW2KuAKiQDXIFdAuapSgQOqgF9O7A6GAWvSmkUiGTg1uKWWDTYYAK5sYI7GCLUQHIwS2YKhA4iIIGiBwV2MAsoiDRwS3JLMkgV8hYofipIiOQZQyygS3WkCnqKdRICXQxggFXwOCgPiMZlArkFsvYAJaxEdwibhG3JLdkqWAejpBG4FDXMGo2UGNnNjfEwG6aDKxoNPNsSRjWJF1DYKDOk+aQc3BwS0GHPIKEapEYHVSQ9O5i2RjBLZYNYgMTVH/EyoaSgQlqVsWSQMUgjz7LkIQBLEC5XDadd8Hd6dj31gRXbaHN8ro99odTd3M47/eb7ud2fx4Wvb1uD8PvaXvUs/rE+sOj/qrg027fG10289WhfWlELH55RAaeJAp/0IgLGsGqepQIBLMCfFCAtgKVkKqCVoFMCvIxDmwrZLKcDwqZhFoKi1GU4lHEWFpR8JejkP8bBefpWeTms8gLCpw8iiiILR9KW6Gw9eygUFTsi1FEaEaxVNcgEl0CJGOzrhfKMiFz1Ug6WpuBLNRl0e3Ic6G7TkviE5E0O3RBg6N4h3Issxf8RyCy2ORp7nIMqSmSFntsyqhyCitFCk3VEa5a9ZMiOIuArBLROg3zzAi4TiTClQiVlSKSZpG8Mhytjbnt4spwIPIsgnFdsSHQXGyYvkGEaJ1IYplE0tVE/ZwI8pUIfoNIWZnYVGaRHLglggvTOefitaY4T5OY/12igGc1F+KmxMJkhSweCeQc13mRwuRFgjUSJUQfzrr7NwP524Od6zS3225xwFOcBrw0SwMX9n0tS09Gytzc7HBh408C/gqVRJqbHS3tdjoA57nM0H4XXHyueSpQHfMrn+v0DhMgrJSAWSJ+WQJXejFNjRIIv1zjV2P0UxLTi622ycpAKLU67VaPtg+744ePChfTOu629/u+Hj6dDw9XZ0+/Xv2Mf5R4Pb489I/nY29KV18m9J8xfffaRKJb/eYQ7FDrQ/dLOxzO6n+DkdLtxZz5DQ==","brillig_names":["get_data_at_index"]},{"name":"get_latest_1_slot_data","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"feed_id","type":{"kind":"field"},"visibility":"private"},{"name":"start_slot","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5534074920259783320":{"error_kind":"string","string":"Function get_latest_1_slot_data can only be called statically"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13265554733035650515":{"error_kind":"string","string":"BigNum::validate_gt check fails"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIDYJwAABAMnAgMEAicCBAQAHwoAAwAEgNUuCIDVAAEuCIDWAAIlAAAAUSUAAAwILgIAAYDXKAIAAgSA1ycCAwQBOw4AAwACKACAQwQALCsAgEQA/+7u7u7u7u7u7u7u7u7u7ysAgEUGAAgAAAAAAAAAAAAAAAAAACgAgEYAAAIpAIBHBgABAAAoAIBIBgAALgAAAYBJKACASgQABAEAAAGASgABKAGASQQAAQEAgEkAAoBKLgCASoBLLgSAR4BLAQCASwACgEsuBIBIgEsBAIBLAAKASy4EgEiASygAgEoBAAArAIBLBgEAAAAAAAAAAAAAAAAAAAAsAIBMAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAKACATQAgACsAgE4GAIAAAAAAAAAAAAAAAAAAACgAgE8EAAEoAIBQBAAOKACAUQQAAigAgFIEAA8oAIBTBAAaKACAVAQAFCgAgFUEAAMoAIBWBAAQKACAVwQARCgAgFgEAFAoAIBZBAAbKACAWgQAFSgAgFsEADgoAIBcBAAyKACAXQQABCgAgF4EABEoAIBfBABBKACAYAQAYCgAgGEEAEUoAIBiBABRKACAYwQAaSgAgGQEAGMoAIBlBAAcKACAZgQAFigAgGcEAFYoAIBoBABaKACAaQQAOSgAgGoEADMoAIBrBABIKACAbAQAKigAgG0EAAUoAIBuBAB+KACAbwQAEigAgHAEAEIoAIBxBAAwKACAcgQAXigAgHMEAGEoAIB0BABUKACAdQQARigAgHYEAHwoAIB3BABSKACAeAQAeigAgHkEAGooAIB6BABkKACAewQAcigAgHwEAGwoAIB9BAAdKACAfgQAFygAgH8EAE0oAICABABmKACAgQQAVygAgIIEAFsoAICDBAB3KACAhAQAdCgAgIUEADooAICGBAA0KACAhwQAPSgAgIgEAG4oAICJBABJKACAigQAJSgAgIsEACsoAICMBAAfKACAjQQABigAgI4EAH8oAICPBAANKACAkAQAGSgAgJEEABMoAICSBABDKACAkwQATygAgJQEADcoAICVBAAxKACAlgQAQCgAgJcEAF8oAICYBABoKACAmQQAYigAgJoEAFUoAICbBABZKACAnAQARygAgJ0EACkoAICeBAB9KACAnwQALygAgKAEAF0oAIChBABTKACAogQAeygAgKMEAHkoAICkBABxKACApQQAaygAgKYEAEwoAICnBABlKACAqAQAdigAgKkEAHMoAICqBAA8KACAqwQAbSgAgKwEACQoAICtBAAeKACArgQADCgAgK8EABgoAICwBABOKACAsQQANigAgLIEAD8oAICzBABnKACAtAQAWCgAgLUEACgoAIC2BAAuKACAtwQAXCgAgLgEAHgoAIC5BABwKACAugQASygAgLsEAHUoAIC8BAA7KACAvQQAIygAgL4EAAsoAIC/BAA1KACAwAQAPigAgMEEACcoAIDCBAAtKACAwwQAbygAgMQEAEooAIDFBAAiKACAxgQACigAgMcEACYoAIDIBAAhKACAyQQACSgAgMoEACAoAIDLBAAIKACAzAQABygAgM0EAIAuAAABgM4oAIDPBACBAQAAAYDPAAEoAYDOBAABAQCAzgACgM8uAIDPgNAuBIBPgNABAIDQAAKA0C4EgFCA0AEAgNAAAoDQLgSAUYDQAQCA0AACgNAuBIBSgNABAIDQAAKA0C4EgFOA0AEAgNAAAoDQLgSAVIDQAQCA0AACgNAuBIBVgNABAIDQAAKA0C4EgFaA0AEAgNAAAoDQLgSAV4DQAQCA0AACgNAuBIBYgNABAIDQAAKA0C4EgFmA0AEAgNAAAoDQLgSAWoDQAQCA0AACgNAuBIBbgNABAIDQAAKA0C4EgFyA0AEAgNAAAoDQLgSAXYDQAQCA0AACgNAuBIBegNABAIDQAAKA0C4EgF+A0AEAgNAAAoDQLgSAYIDQAQCA0AACgNAuBIBhgNABAIDQAAKA0C4EgGKA0AEAgNAAAoDQLgSAY4DQAQCA0AACgNAuBIBkgNABAIDQAAKA0C4EgGWA0AEAgNAAAoDQLgSAZoDQAQCA0AACgNAuBIBngNABAIDQAAKA0C4EgGiA0AEAgNAAAoDQLgSAaYDQAQCA0AACgNAuBIBqgNABAIDQAAKA0C4EgGuA0AEAgNAAAoDQLgSAbIDQAQCA0AACgNAuBIBtgNABAIDQAAKA0C4EgG6A0AEAgNAAAoDQLgSAb4DQAQCA0AACgNAuBIBwgNABAIDQAAKA0C4EgHGA0AEAgNAAAoDQLgSAcoDQAQCA0AACgNAuBIBzgNABAIDQAAKA0C4EgHSA0AEAgNAAAoDQLgSAdYDQAQCA0AACgNAuBIB2gNABAIDQAAKA0C4EgHeA0AEAgNAAAoDQLgSAeIDQAQCA0AACgNAuBIB5gNABAIDQAAKA0C4EgHqA0AEAgNAAAoDQLgSAe4DQAQCA0AACgNAuBIB8gNABAIDQAAKA0C4EgH2A0AEAgNAAAoDQLgSAfoDQAQCA0AACgNAuBIB/gNABAIDQAAKA0C4EgICA0AEAgNAAAoDQLgSAgYDQAQCA0AACgNAuBICCgNABAIDQAAKA0C4EgIOA0AEAgNAAAoDQLgSAhIDQAQCA0AACgNAuBICFgNABAIDQAAKA0C4EgIaA0AEAgNAAAoDQLgSAh4DQAQCA0AACgNAuBICIgNABAIDQAAKA0C4EgImA0AEAgNAAAoDQLgSAioDQAQCA0AACgNAuBICLgNABAIDQAAKA0C4EgIyA0AEAgNAAAoDQLgSAjYDQAQCA0AACgNAuBICOgNABAIDQAAKA0C4EgI+A0AEAgNAAAoDQLgSAkIDQAQCA0AACgNAuBICRgNABAIDQAAKA0C4EgJKA0AEAgNAAAoDQLgSAk4DQAQCA0AACgNAuBICUgNABAIDQAAKA0C4EgJWA0AEAgNAAAoDQLgSAloDQAQCA0AACgNAuBICXgNABAIDQAAKA0C4EgJiA0AEAgNAAAoDQLgSAmYDQAQCA0AACgNAuBICagNABAIDQAAKA0C4EgJuA0AEAgNAAAoDQLgSAnIDQAQCA0AACgNAuBICdgNABAIDQAAKA0C4EgJ6A0AEAgNAAAoDQLgSAn4DQAQCA0AACgNAuBICggNABAIDQAAKA0C4EgKGA0AEAgNAAAoDQLgSAooDQAQCA0AACgNAuBICjgNABAIDQAAKA0C4EgKSA0AEAgNAAAoDQLgSApYDQAQCA0AACgNAuBICmgNABAIDQAAKA0C4EgKeA0AEAgNAAAoDQLgSAqIDQAQCA0AACgNAuBICpgNABAIDQAAKA0C4EgKqA0AEAgNAAAoDQLgSAq4DQAQCA0AACgNAuBICsgNABAIDQAAKA0C4EgK2A0AEAgNAAAoDQLgSAroDQAQCA0AACgNAuBICvgNABAIDQAAKA0C4EgLCA0AEAgNAAAoDQLgSAsYDQAQCA0AACgNAuBICygNABAIDQAAKA0C4EgLOA0AEAgNAAAoDQLgSAtIDQAQCA0AACgNAuBIC1gNABAIDQAAKA0C4EgLaA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","debug_symbols":"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","brillig_names":["get_latest_1_slot_data"]},{"name":"get_latest_data","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"feed_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"11145567096809749512":{"error_kind":"string","string":"Function get_latest_data can only be called statically"},"13265554733035650515":{"error_kind":"string","string":"BigNum::validate_gt check fails"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIDXJwAABAMnAgIEAScCAwQAHwoAAgADgNUuCIDVAAElAAAASyUAAAwCLgIAAYDWKAIAAgSA1icCAwQBOw4AAwACKACAQwQALCsAgEQA/+7u7u7u7u7u7u7u7u7u7ysAgEUGAAgAAAAAAAAAAAAAAAAAACgAgEYAAAIpAIBHBgABAAAoAIBIBgAALgAAAYBJKACASgQABAEAAAGASgABKAGASQQAAQEAgEkAAoBKLgCASoBLLgSAR4BLAQCASwACgEsuBIBIgEsBAIBLAAKASy4EgEiASywAgEoAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAoAIBLACAAKACATAEAACsAgE0GAQAAAAAAAAAAAAAAAAAAACsAgE4GAIAAAAAAAAAAAAAAAAAAACgAgE8EAAEoAIBQBAAOKACAUQQAAigAgFIEAA8oAIBTBAAaKACAVAQAFCgAgFUEAAMoAIBWBAAQKACAVwQARCgAgFgEAFAoAIBZBAAbKACAWgQAFSgAgFsEADgoAIBcBAAyKACAXQQABCgAgF4EABEoAIBfBABBKACAYAQAYCgAgGEEAEUoAIBiBABRKACAYwQAaSgAgGQEAGMoAIBlBAAcKACAZgQAFigAgGcEAFYoAIBoBABaKACAaQQAOSgAgGoEADMoAIBrBABIKACAbAQAKigAgG0EAAUoAIBuBAB+KACAbwQAEigAgHAEAEIoAIBxBAAwKACAcgQAXigAgHMEAGEoAIB0BABUKACAdQQARigAgHYEAHwoAIB3BABSKACAeAQAeigAgHkEAGooAIB6BABkKACAewQAcigAgHwEAGwoAIB9BAAdKACAfgQAFygAgH8EAE0oAICABABmKACAgQQAVygAgIIEAFsoAICDBAB3KACAhAQAdCgAgIUEADooAICGBAA0KACAhwQAPSgAgIgEAG4oAICJBABJKACAigQAJSgAgIsEACsoAICMBAAfKACAjQQABigAgI4EAH8oAICPBAANKACAkAQAGSgAgJEEABMoAICSBABDKACAkwQATygAgJQEADcoAICVBAAxKACAlgQAQCgAgJcEAF8oAICYBABoKACAmQQAYigAgJoEAFUoAICbBABZKACAnAQARygAgJ0EACkoAICeBAB9KACAnwQALygAgKAEAF0oAIChBABTKACAogQAeygAgKMEAHkoAICkBABxKACApQQAaygAgKYEAEwoAICnBABlKACAqAQAdigAgKkEAHMoAICqBAA8KACAqwQAbSgAgKwEACQoAICtBAAeKACArgQADCgAgK8EABgoAICwBABOKACAsQQANigAgLIEAD8oAICzBABnKACAtAQAWCgAgLUEACgoAIC2BAAuKACAtwQAXCgAgLgEAHgoAIC5BABwKACAugQASygAgLsEAHUoAIC8BAA7KACAvQQAIygAgL4EAAsoAIC/BAA1KACAwAQAPigAgMEEACcoAIDCBAAtKACAwwQAbygAgMQEAEooAIDFBAAiKACAxgQACigAgMcEACYoAIDIBAAhKACAyQQACSgAgMoEACAoAIDLBAAIKACAzAQABygAgM0EAIAuAAABgM4oAIDPBACBAQAAAYDPAAEoAYDOBAABAQCAzgACgM8uAIDPgNAuBIBPgNABAIDQAAKA0C4EgFCA0AEAgNAAAoDQLgSAUYDQAQCA0AACgNAuBIBSgNABAIDQAAKA0C4EgFOA0AEAgNAAAoDQLgSAVIDQAQCA0AACgNAuBIBVgNABAIDQAAKA0C4EgFaA0AEAgNAAAoDQLgSAV4DQAQCA0AACgNAuBIBYgNABAIDQAAKA0C4EgFmA0AEAgNAAAoDQLgSAWoDQAQCA0AACgNAuBIBbgNABAIDQAAKA0C4EgFyA0AEAgNAAAoDQLgSAXYDQAQCA0AACgNAuBIBegNABAIDQAAKA0C4EgF+A0AEAgNAAAoDQLgSAYIDQAQCA0AACgNAuBIBhgNABAIDQAAKA0C4EgGKA0AEAgNAAAoDQLgSAY4DQAQCA0AACgNAuBIBkgNABAIDQAAKA0C4EgGWA0AEAgNAAAoDQLgSAZoDQAQCA0AACgNAuBIBngNABAIDQAAKA0C4EgGiA0AEAgNAAAoDQLgSAaYDQAQCA0AACgNAuBIBqgNABAIDQAAKA0C4EgGuA0AEAgNAAAoDQLgSAbIDQAQCA0AACgNAuBIBtgNABAIDQAAKA0C4EgG6A0AEAgNAAAoDQLgSAb4DQAQCA0AACgNAuBIBwgNABAIDQAAKA0C4EgHGA0AEAgNAAAoDQLgSAcoDQAQCA0AACgNAuBIBzgNABAIDQAAKA0C4EgHSA0AEAgNAAAoDQLgSAdYDQAQCA0AACgNAuBIB2gNABAIDQAAKA0C4EgHeA0AEAgNAAAoDQLgSAeIDQAQCA0AACgNAuBIB5gNABAIDQAAKA0C4EgHqA0AEAgNAAAoDQLgSAe4DQAQCA0AACgNAuBIB8gNABAIDQAAKA0C4EgH2A0AEAgNAAAoDQLgSAfoDQAQCA0AACgNAuBIB/gNABAIDQAAKA0C4EgICA0AEAgNAAAoDQLgSAgYDQAQCA0AACgNAuBICCgNABAIDQAAKA0C4EgIOA0AEAgNAAAoDQLgSAhIDQAQCA0AACgNAuBICFgNABAIDQAAKA0C4EgIaA0AEAgNAAAoDQLgSAh4DQAQCA0AACgNAuBICIgNABAIDQAAKA0C4EgImA0AEAgNAAAoDQLgSAioDQAQCA0AACgNAuBICLgNABAIDQAAKA0C4EgIyA0AEAgNAAAoDQLgSAjYDQAQCA0AACgNAuBICOgNABAIDQAAKA0C4EgI+A0AEAgNAAAoDQLgSAkIDQAQCA0AACgNAuBICRgNABAIDQAAKA0C4EgJKA0AEAgNAAAoDQLgSAk4DQAQCA0AACgNAuBICUgNABAIDQAAKA0C4EgJWA0AEAgNAAAoDQLgSAloDQAQCA0AACgNAuBICXgNABAIDQAAKA0C4EgJiA0AEAgNAAAoDQLgSAmYDQAQCA0AACgNAuBICagNABAIDQAAKA0C4EgJuA0AEAgNAAAoDQLgSAnIDQAQCA0AACgNAuBICdgNABAIDQAAKA0C4EgJ6A0AEAgNAAAoDQLgSAn4DQAQCA0AACgNAuBICggNABAIDQAAKA0C4EgKGA0AEAgNAAAoDQLgSAooDQAQCA0AACgNAuBICjgNABAIDQAAKA0C4EgKSA0AEAgNAAAoDQLgSApYDQAQCA0AACgNAuBICmgNABAIDQAAKA0C4EgKeA0AEAgNAAAoDQLgSAqIDQAQCA0AACgNAuBICpgNABAIDQAAKA0C4EgKqA0AEAgNAAAoDQLgSAq4DQAQCA0AACgNAuBICsgNABAIDQAAKA0C4EgK2A0AEAgNAAAoDQLgSAroDQAQCA0AACgNAuBICvgNABAIDQAAKA0C4EgLCA0AEAgNAAAoDQLgSAsYDQAQCA0AACgNAuBICygNABAIDQAAKA0C4EgLOA0AEAgNAAAoDQLgSAtIDQAQCA0AACgNAuBIC1gNABAIDQAAKA0C4EgLaA0AEAgNAA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DhIPASIACYBPABAtChAJIwAAHSEAIgECDgAqDggPLQsPCy0LBw4AKgsODw4qCw8QJAIAEAAAH+ElAAAWOhsiAA+A1AALLQ4LBxkiAAuA1AAOAioPDgsOKg4PECQCABAAACAMJQAAFl4tCwkOLgIADoADKACABAQABCUAACGMLgiABQAPACIPAhAAKhAIES0OCxEtDg8JASIACIBPAAstCgsIIwAAGvItCwcCACICAgItDgIHLQoHAy0KAQQjAAAgZS0LAwEAIgECAS0OAQMtCgMBLQoEAiYlAAAVTS0IAQQAAAECAS4MgEwABC0IAQUAAAECAS4MgEwABS4IgM8AAyMAACCpDSIAA4BVAAYkAgAGAAAgviMAACEyAyiAUQADAAYPIgADgFEAByQCAAcAACDbJQAAFl4NIgAGgFUAByQCAAcAACDwJQAAI28AIgICCAAqCAYJLQsJBwAiAQIJACoJBgotCwoICioHCAYkAgAGAAAheyMAACEeDCoHCAMtDgMELgyA0AAFIwAAITItCwUGJAIABgAAIWkjAAAhQwEiAAGATwAFLQsFBAEiAAKATwAFLQsFAQoqBAECLQoCAyMAACF2LQsEAS0KAQMjAAAhdi0KAwEmASIAA4BPAAYtCgYDIwAAIKkuAYADgAYLAIAGAAKAByQAgAcAACGnIwAAIbIuAIADgAUjAAAiGS4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAACIFLgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAACHUKAGABQQAAQMAgAYAAoAGIwAAIhkmJQAAFU0BIgABgE8AAy0LAwIcCgIDABwKAwIAKwIABAAA////////////////////DioCBAUkAgAFAAAiXCUAACkkASIAAYBRAAMtCwMCHAoCAwAcCgMCACsCAAQAAP///////////////////w4qAgQFJAIABQAAIpklAAApJAEiAAGAVQADLQsDAhwKAgEAHAoBAgApAgADAAAB//8OKgIDBCQCAAQAACLKJQAAKSQmKgEAAQW4GLe+6xd90zwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKACABgQAAgcAgASABoAFLgCABIAIKACACQQAAA0AgAmABYAKFwCACoAKJACACgAAI24DAIAIAAKA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","debug_symbols":"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","brillig_names":["get_latest_data"]},{"name":"get_latest_data_and_index","is_unconstrained":true,"custom_attributes":["public","view"],"abi":{"parameters":[{"name":"feed_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"AggregatedDataFeedStore::LatestDataAndIndex","fields":[{"name":"latest_index","type":{"kind":"field"}},{"name":"latest_data","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{"730596019049412512":{"error_kind":"string","string":"Function get_latest_data_and_index can only be called statically"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13265554733035650515":{"error_kind":"string","string":"BigNum::validate_gt check fails"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIDYJwAABAMnAgIEAScCAwQAHwoAAgADgNUuCIDVAAElAAAAUSUAAAwILgIAAYDWLgIAAoDXKAIAAwSA1icCBAQCOw4ABAADKACAQwQALCsAgEQA/+7u7u7u7u7u7u7u7u7u7ysAgEUGAAgAAAAAAAAAAAAAAAAAACgAgEYAAAIpAIBHBgABAAAoAIBIBgAALgAAAYBJKACASgQABAEAAAGASgABKAGASQQAAQEAgEkAAoBKLgCASoBLLgSAR4BLAQCASwACgEsuBIBIgEsBAIBLAAKASy4EgEiASywAgEoAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAoAIBLACAAKACATAEAACsAgE0GAQAAAAAAAAAAAAAAAAAAACsAgE4GAIAAAAAAAAAAAAAAAAAAACgAgE8EAAEoAIBQBAAOKACAUQQAAigAgFIEAA8oAIBTBAAaKACAVAQAFCgAgFUEAAMoAIBWBAAQKACAVwQARCgAgFgEAFAoAIBZBAAbKACAWgQAFSgAgFsEADgoAIBcBAAyKACAXQQABCgAgF4EABEoAIBfBABBKACAYAQAYCgAgGEEAEUoAIBiBABRKACAYwQAaSgAgGQEAGMoAIBlBAAcKACAZgQAFigAgGcEAFYoAIBoBABaKACAaQQAOSgAgGoEADMoAIBrBABIKACAbAQAKigAgG0EAAUoAIBuBAB+KACAbwQAEigAgHAEAEIoAIBxBAAwKACAcgQAXigAgHMEAGEoAIB0BABUKACAdQQARigAgHYEAHwoAIB3BABSKACAeAQAeigAgHkEAGooAIB6BABkKACAewQAcigAgHwEAGwoAIB9BAAdKACAfgQAFygAgH8EAE0oAICABABmKACAgQQAVygAgIIEAFsoAICDBAB3KACAhAQAdCgAgIUEADooAICGBAA0KACAhwQAPSgAgIgEAG4oAICJBABJKACAigQAJSgAgIsEACsoAICMBAAfKACAjQQABigAgI4EAH8oAICPBAANKACAkAQAGSgAgJEEABMoAICSBABDKACAkwQATygAgJQEADcoAICVBAAxKACAlgQAQCgAgJcEAF8oAICYBABoKACAmQQAYigAgJoEAFUoAICbBABZKACAnAQARygAgJ0EACkoAICeBAB9KACAnwQALygAgKAEAF0oAIChBABTKACAogQAeygAgKMEAHkoAICkBABxKACApQQAaygAgKYEAEwoAICnBABlKACAqAQAdigAgKkEAHMoAICqBAA8KACAqwQAbSgAgKwEACQoAICtBAAeKACArgQADCgAgK8EABgoAICwBABOKACAsQQANigAgLIEAD8oAICzBABnKACAtAQAWCgAgLUEACgoAIC2BAAuKACAtwQAXCgAgLgEAHgoAIC5BABwKACAugQASygAgLsEAHUoAIC8BAA7KACAvQQAIygAgL4EAAsoAIC/BAA1KACAwAQAPigAgMEEACcoAIDCBAAtKACAwwQAbygAgMQEAEooAIDFBAAiKACAxgQACigAgMcEACYoAIDIBAAhKACAyQQACSgAgMoEACAoAIDLBAAIKACAzAQABygAgM0EAIAuAAABgM4oAIDPBACBAQAAAYDPAAEoAYDOBAABAQCAzgACgM8uAIDPgNAuBIBPgNABAIDQAAKA0C4EgFCA0AEAgNAAAoDQLgSAUYDQAQCA0AACgNAuBIBSgNABAIDQAAKA0C4EgFOA0AEAgNAAAoDQLgSAVIDQAQCA0AACgNAuBIBVgNABAIDQAAKA0C4EgFaA0AEAgNAAAoDQLgSAV4DQAQCA0AACgNAuBIBYgNABAIDQAAKA0C4EgFmA0AEAgNAAAoDQLgSAWoDQAQCA0AACgNAuBIBbgNABAIDQAAKA0C4EgFyA0AEAgNAAAoDQLgSAXYDQAQCA0AACgNAuBIBegNABAIDQAAKA0C4EgF+A0AEAgNAAAoDQLgSAYIDQAQCA0AACgNAuBIBhgNABAIDQAAKA0C4EgGKA0AEAgNAAAoDQLgSAY4DQAQCA0AACgNAuBIBkgNABAIDQAAKA0C4EgGWA0AEAgNAAAoDQLgSAZoDQAQCA0AACgNAuBIBngNABAIDQAAKA0C4EgGiA0AEAgNAAAoDQLgSAaYDQAQCA0AACgNAuBIBqgNABAIDQAAKA0C4EgGuA0AEAgNAAAoDQLgSAbIDQAQCA0AACgNAuBIBtgNABAIDQAAKA0C4EgG6A0AEAgNAAAoDQLgSAb4DQAQCA0AACgNAuBIBwgNABAIDQAAKA0C4EgHGA0AEAgNAAAoDQLgSAcoDQAQCA0AACgNAuBIBzgNABAIDQAAKA0C4EgHSA0AEAgNAAAoDQLgSAdYDQAQCA0AACgNAuBIB2gNABAIDQAAKA0C4EgHeA0AEAgNAAAoDQLgSAeIDQAQCA0AACgNAuBIB5gNABAIDQAAKA0C4EgHqA0AEAgNAAAoDQLgSAe4DQAQCA0AACgNAuBIB8gNABAIDQAAKA0C4EgH2A0AEAgNAAAoDQLgSAfoDQAQCA0AACgNAuBIB/gNABAIDQAAKA0C4EgICA0AEAgNAAAoDQLgSAgYDQAQCA0AACgNAuBICCgNABAIDQAAKA0C4EgIOA0AEAgNAAAoDQLgSAhIDQAQCA0AACgNAuBICFgNABAIDQAAKA0C4EgIaA0AEAgNAAAoDQLgSAh4DQAQCA0AACgNAuBICIgNABAIDQAAKA0C4EgImA0AEAgNAAAoDQLgSAioDQAQCA0AACgNAuBICLgNABAIDQAAKA0C4EgIyA0AEAgNAAAoDQLgSAjYDQAQCA0AACgNAuBICOgNABAIDQAAKA0C4EgI+A0AEAgNAAAoDQLgSAkIDQAQCA0AACgNAuBICRgNABAIDQAAKA0C4EgJKA0AEAgNAAAoDQLgSAk4DQAQCA0AACgNAuBICUgNABAIDQAAKA0C4EgJWA0AEAgNAAAoDQLgSAloDQAQCA0AACgNAuBICXgNABAIDQAAKA0C4EgJiA0AEAgNAAAoDQLgSAmYDQAQCA0AACgNAuBICagNABAIDQAAKA0C4EgJuA0AEAgNAAAoDQLgSAnIDQAQCA0AACgNAuBICdgNABAIDQAAKA0C4EgJ6A0AEAgNAAAoDQLgSAn4DQAQCA0AACgNAuBICggNABAIDQAAKA0C4EgKGA0AEAgNAAAoDQLgSAooDQAQCA0AACgNAuBICjgNABAIDQAAKA0C4EgKSA0AEAgNAAAoDQLgSApYDQAQCA0AACgNAuBICmgNABAIDQAAKA0C4EgKeA0AEAgNAAAoDQLgSAqIDQAQCA0AACgNAuBICpgNABAIDQAAKA0C4EgKqA0AEAgNAAAoDQLgSAq4DQAQCA0AACgNAuBICsgNABAIDQAAKA0C4EgK2A0AEAgNAAAoDQLgSAroDQAQCA0AACgNAuBICvgNABAIDQAAKA0C4EgLCA0AEAgNAAAoDQLgSAsYDQAQCA0AACgNAuBICygNABAIDQAAKA0C4EgLOA0AEAgNAAAoDQLgSAtIDQAQCA0AACgNAuBIC1gNABAIDQAAKA0C4EgLaA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IhMCFAAqFAkVLQ4QFS0OEw4tDhIPASIACYBPABAtChAJIwAAHTMAIgECDgAqDggPLQsPCy0LBw4AKgsODw4qCw8QJAIAEAAAH/MlAAAWTBsiAA+A1AALLQ4LBxkiAAuA1AAOAioPDgsOKg4PECQCABAAACAeJQAAFnAtCwkOLgIADoADKACABAQABCUAACGeLgiABQAPACIPAhAAKhAIES0OCxEtDg8JASIACIBPAAstCgsIIwAAGwQtCwcCACICAgItDgIHLQoHAy0KAQQjAAAgdy0LAwEAIgECAS0OAQMtCgMBLQoEAiYlAAAVXy0IAQQAAAECAS4MgEwABC0IAQUAAAECAS4MgEwABS4IgM8AAyMAACC7DSIAA4BVAAYkAgAGAAAg0CMAACFEAyiAUQADAAYPIgADgFEAByQCAAcAACDtJQAAFnANIgAGgFUAByQCAAcAACECJQAAI4EAIgICCAAqCAYJLQsJBwAiAQIJACoJBgotCwoICioHCAYkAgAGAAAhjSMAACEwDCoHCAMtDgMELgyA0AAFIwAAIUQtCwUGJAIABgAAIXsjAAAhVQEiAAGATwAFLQsFBAEiAAKATwAFLQsFAQoqBAECLQoCAyMAACGILQsEAS0KAQMjAAAhiC0KAwEmASIAA4BPAAYtCgYDIwAAILsuAYADgAYLAIAGAAKAByQAgAcAACG5IwAAIcQuAIADgAUjAAAiKy4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAACIXLgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAACHmKAGABQQAAQMAgAYAAoAGIwAAIismJQAAFV8BIgABgE8AAy0LAwIcCgIDABwKAwIAKwIABAAA////////////////////DioCBAUkAgAFAAAibiUAACk2ASIAAYBRAAMtCwMCHAoCAwAcCgMCACsCAAQAAP///////////////////w4qAgQFJAIABQAAIqslAAApNgEiAAGAVQADLQsDAhwKAgEAHAoBAgApAgADAAAB//8OKgIDBCQCAAQAACLcJQAAKTYmKgEAAQW4GLe+6xd90zwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKACABgQAAgcAgASABoAFLgCABIAIKACACQQAAA0AgAmABYAKFwCA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","debug_symbols":"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","brillig_names":["get_latest_data_and_index"]},{"name":"get_latest_index","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"feed_id","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"13265554733035650515":{"error_kind":"string","string":"BigNum::validate_gt check fails"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIDUJwAABAMnAgIEAScCAwQAHwoAAgADgNIuCIDSAAElAAAASyUAAAvPLgIAAYDTKAIAAgSA0ycCAwQBOw4AAwACKwCAQwD/7u7u7u7u7u7u7u7u7u7vKwCARAYACAAAAAAAAAAAAAAAAAAAKACARQAAAikAgEYGAAEAACgAgEcGAAAuAAABgEgoAIBJBAAEAQAAAYBJAAEoAYBIBAABAQCASAACgEkuAIBJgEouBIBGgEoBAIBKAAKASi4EgEeASgEAgEoAAoBKLgSAR4BKKACASQQALCgAgEoBAAArAIBLBgEAAAAAAAAAAAAAAAAAAAArAIBMBgCAAAAAAAAAAAAAAAAAAAAoAIBNBAABKACATgQADigAgE8EAAIoAIBQBAAPKACAUQQAGigAgFIEABQoAIBTBAADKACAVAQAECgAgFUEAEQoAIBWBABQKACAVwQAGygAgFgEABUoAIBZBAA4KACAWgQAMigAgFsEAAQoAIBcBAARKACAXQQAQSgAgF4EAGAoAIBfBABFKACAYAQAUSgAgGEEAGkoAIBiBABjKACAYwQAHCgAgGQEABYoAIBlBABWKACAZgQAWigAgGcEADkoAIBoBAAzKACAaQQASCgAgGoEACooAIBrBAAFKACAbAQAfigAgG0EABIoAIBuBABCKACAbwQAMCgAgHAEAF4oAIBxBABhKACAcgQAVCgAgHMEAEYoAIB0BAB8KACAdQQAUigAgHYEAHooAIB3BABqKACAeAQAZCgAgHkEAHIoAIB6BABsKACAewQAHSgAgHwEABcoAIB9BABNKACAfgQAZigAgH8EAFcoAICABABbKACAgQQAdygAgIIEAHQoAICDBAA6KACAhAQANCgAgIUEAD0oAICGBABuKACAhwQASSgAgIgEACUoAICJBAArKACAigQAHygAgIsEAAYoAICMBAB/KACAjQQADSgAgI4EABkoAICPBAATKACAkAQAQygAgJEEAE8oAICSBAA3KACAkwQAMSgAgJQEAEAoAICVBABfKACAlgQAaCgAgJcEAGIoAICYBABVKACAmQQAWSgAgJoEAEcoAICbBAApKACAnAQAfSgAgJ0EAC8oAICeBABdKACAnwQAUygAgKAEAHsoAIChBAB5KACAogQAcSgAgKMEAGsoAICkBABMKACApQQAZSgAgKYEAHYoAICnBABzKACAqAQAPCgAgKkEAG0oAICqBAAkKACAqwQAHigAgKwEAAwoAICtBAAYKACArgQATigAgK8EADYoAICwBAA/KACAsQQAZygAgLIEAFgoAICzBAAoKACAtAQALigAgLUEAFwoAIC2BAB4KACAtwQAcCgAgLgEAEsoAIC5BAB1KACAugQAOygAgLsEACMoAIC8BAALKACAvQQANSgAgL4EAD4oAIC/BAAnKACAwAQALSgAgMEEAG8oAIDCBABKKACAwwQAIigAgMQEAAooAIDFBAAmKACAxgQAISgAgMcEAAkoAIDIBAAgKACAyQQACCgAgMoEAAcoAIDLBACALgAAAYDMKACAzQQAgQEAAAGAzQABKAGAzAQAAQEAgMwAAoDNLgCAzYDOLgSATYDOAQCAzgACgM4uBIBOgM4BAIDOAAKAzi4EgE+AzgEAgM4AAoDOLgSAUIDOAQCAzgACgM4uBIBRgM4BAIDOAAKAzi4EgFKAzgEAgM4AAoDOLgSAU4DOAQCAzgACgM4uBIBUgM4BAIDOAAKAzi4EgFWAzgEAgM4AAoDOLgSAVoDOAQCAzgACgM4uBIBXgM4BAIDOAAKAzi4EgFiAzgEAgM4AAoDOLgSAWYDOAQCAzgACgM4uBIBagM4BAIDOAAKAzi4EgFuAzgEAgM4AAoDOLgSAXIDOAQCAzgACgM4uBIBdgM4BAIDOAAKAzi4EgF6AzgEAgM4AAoDOLgSAX4DOAQCAzgACgM4uBIBggM4BAIDOAAKAzi4EgGGAzgEAgM4AAoDOLgSAYoDOAQCAzgACgM4uBIBjgM4BAIDOAAKAzi4EgGSAzgEAgM4AAoDOLgSAZYDOAQCAzgACgM4uBIBmgM4BAIDOAAKAzi4EgGeAzgEAgM4AAoDOLgSAaIDOAQCAzgACgM4uBIBpgM4BAIDOAAKAzi4EgGqAzgEAgM4AAoDOLgSAa4DOAQCAzgACgM4uBIBsgM4BAIDOAAKAzi4EgG2AzgEAgM4AAoDOLgSAboDOAQCAzgACgM4uBIBvgM4BAIDOAAKAzi4EgHCAzgEAgM4AAoDOLgSAcYDOAQCAzgACgM4uBIBygM4BAIDOAAKAzi4EgHOAzgEAgM4AAoDOLgSAdIDOAQCAzgACgM4uBIB1gM4BAIDOAAKAzi4EgHaAzgEAgM4AAoDOLgSAd4DOAQCAzgACgM4uBIB4gM4BAIDOAAKAzi4EgHmAzgEAgM4AAoDOLgSAeoDOAQCAzgACgM4uBIB7gM4BAIDOAAKAzi4EgHyAzgEAgM4AAoDOLgSAfYDOAQCAzgACgM4uBIB+gM4BAIDOAAKAzi4EgH+AzgEAgM4AAoDOLgSAgIDOAQCAzgACgM4uBICBgM4BAIDOAAKAzi4EgIKAzgEAgM4AAoDOLgSAg4DOAQCAzgACgM4uBICEgM4BAIDOAAKAzi4EgIWAzgEAgM4AAoDOLgSAhoDOAQCAzgACgM4uBICHgM4BAIDOAAKAzi4EgIiAzgEAgM4AAoDOLgSAiYDOAQCAzgACgM4uBICKgM4BAIDOAAKAzi4EgIuAzgEAgM4AAoDOLgSAjIDOAQCAzgACgM4uBICNgM4BAIDOAAKAzi4EgI6AzgEAgM4AAoDOLgSAj4DOAQCAzgACgM4uBICQgM4BAIDOAAKAzi4EgJGAzgEAgM4AAoDOLgSAkoDOAQCAzgACgM4uBICTgM4BAIDOAAKAzi4EgJSAzgEAgM4AAoDOLgSAlYDOAQCAzgACgM4uBICWgM4BAIDOAAKAzi4EgJeAzgEAgM4AAoDOLgSAmIDOAQCAzgACgM4uBICZgM4BAIDOAAKAzi4EgJqAzgEAgM4AAoDOLgSAm4DOAQCAzgACgM4uBICcgM4BAIDOAAKAzi4EgJ2AzgEAgM4AAoDOLgSAnoDOAQCAzgACgM4uBICfgM4BAIDOAAKAzi4EgKCAzgEAgM4AAoDOLgSAoYDOAQCAzgACgM4uBICigM4BAIDOAAKAzi4EgKOAzgEAgM4AAoDOLgSApIDOAQCAzgACgM4uBIClgM4BAIDOAAKAzi4EgKaAzgEAgM4AAoDOLgSAp4DOAQCAzgACgM4uBICogM4BAIDOAAKAzi4EgKmAzgEAgM4AAoDOLgSAqoDOAQCAzgACgM4uBICrgM4BAIDOAAKAzi4EgKyAzgEAgM4AAoDOLgSArYDOAQCAzgACgM4uBICugM4BAIDOAAKAzi4EgK+AzgEAgM4AAoDOLgSAsIDOAQCAzgACgM4uBICxgM4BAIDOAAKAzi4EgLKAzgEAgM4AAoDOLgSAs4DOAQCAzgACgM4uBIC0gM4BAIDOAAKAzi4EgLWAzgEAgM4AAoDOLgSAtoDOAQCAzgACgM4uBIC3gM4BAIDOAAKA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IgECCQAqCQYKLQsKCAoqBwgGJAIABgAAICAjAAAfwwwqBwgDLQ4DBC4MgM4ABSMAAB/XLQsFBiQCAAYAACAOIwAAH+gBIgABgE0ABS0LBQQBIgACgE0ABS0LBQEKKgQBAi0KAgMjAAAgGy0LBAEtCgEDIwAAIBstCgMBJgEiAAOATQAGLQoGAyMAAB9OLgGAA4AGCwCABgACgAckAIAHAAAgTCMAACBXLgCAA4AFIwAAIL4uAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAgqi4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAgeSgBgAUEAAEDAIAGAAKABiMAACC+JiUAABUmASIAAYBNAAMtCwMCHAoCAwAcCgMCACsCAAQAAP///////////////////w4qAgQFJAIABQAAIQElAAAnNwEiAAGATwADLQsDAhwKAgMAHAoDAgArAgAEAAD///////////////////8OKgIEBSQCAAUAACE+JQAAJzcBIgABgFMAAy0LAwIcCgIBABwKAQIAKQIAAwAAAf//DioCAwQkAgAEAAAhbyUAACc3JioBAAEFuBi3vusXfdM8BAIBJioBAAEFxWvEWg4QAAI8BAIBJiUAABUmLQgBAwAAAQIBLgyAzQADLgiAzQACIwAAIbMNIgACgFMABCQCAAQAACHIIwAAI6QDKIBPAAIABA8iAAKATwAFJAIABQAAIeUlAAAVhQ0iAASAUwAFJAIABQAAIfolAAAhggAiAQIGACoGBActCwcFDSiARwAFAAYkAgAGAAAiLiMAACIdASIAAoBNAAQtCgQCIwAAIbMFKIC2AAQAAicCBwQACioHBAYkAgAGAAAiYgYqAgQJCyIACYC2AAgkAgAIAAAiYiUAABVzCyIABYBHAAQkAgAEAAAjeSMAACJ3GyIABYDPAAQSKgUEBicCBAICGioGBAUSKgYFBCcCBQIEGioEBQYSKgQGBScCBAIIGioFBAYSKgUGBCcCBQIQGioEBQYSKgQGBScCBAIgGioFBAYSKgUGBCcCBQJAGioEBQYSKgQGBRwKBQQAKwIABQAB/BDC+89HG5E7FM0lldbVBCoEBQYcCgYFBhwKBQQAHAoEBQYnAgQCeRoqBQQGHAoGBAAcCgQFACkCAAcA/////w4qBQcIJAIACAAAIzslAAAnNxwKBgUEHAoFBAYcCgQFBA0iAAWAywAEJAIABAAAI18lAAAhggEggMwAAgAGACoGBQctCwcELQoEASMAACOELgiAzQABIwAAI4QAKgIBBA4qAgQFJAIABQAAI5slAAAVYS0OBAMjAAAjpC0LAwEmJQAAFSYtCAEEJwIFBAQACAEFAScDBAQBACIEAgUtCgUGLgyARwAGACIGAgYuDIBHAAYAIgYCBi4MgEcABi0IAQUAAAECAQciAAKAtgAGByIAAoC2AAgFIgAIgLYACQIqAgkHHAoHCAIcCggCBBwKAgcCAyiA0QAHAAIPIgAHgNEACCQCAAgAACQ4JQAAFYUBIgABgE0ACS0LCQgaKggCCS0IAQoAAAECAS0OCQoYKggHCScCCAKADCoHCAskAgALAAAkciUAACdJKwIACwYBAAAAAAAAAAAAAAAAAAAABioJCwwEKgwLDQIqCQ0IDSIABoBTAAkkAgAJAAAkqyUAACGCLgIABIADKACABAQABCUAACAxLgiABQAJACIJAgsAKgsGDC0OCAwtDgkFAyiAUwAGAAQPIgAGgFMACCQCAAgAACTyJQAAFYUuCIBNAAMjAAAk/QwqAwQIJAIACAAAJRQjAAAlDy0LBQEmDSIAA4BTAAgkAgAIAAAlKSUAACGCACIBAgkAKgkDCy0LCwgYKggHCS0LCgsAKgkLDA4qCQwNJAIADQAAJVclAAAVYSsCAAsGAQAAAAAAAAAAAAAAAAAAAAYqDAsNBCoNCw4CKgwOCQAqAwYLDioDCwwkAgAMAAAlkiUAABVhLQsFDA0iAAuAUwANJAIADQAAJaslAAAhgi4CAAyAAygAgAQEAAQlAAAgMS4IgAUADQAiDQIOACoOCw8tDgkPLQ4NBRoqCAIJLQ4JCgEiAAOATQAILQoIAyMAACT9JQAAFSYtCAEDAAABAgEBIgABgFMABS0LBQQbIgAEgM8ABS4CAAGAAygAgAQEAAQlAAAgMS4IgAUABgAiBgIHASIAB4BPAAgtDgUILQ4GAxwKBAUBHAoFAQYnAgQCdxgqAQQFLQgBAQAAAQIBLQ4FAS4IgE0AAiMAACZqDSIAAoBTAAUkAgAFAAAmhCMAACZ/LQsDASYtCwMFAyiATwACAAYPIgACgE8AByQCAAcAACalJQAAFYUNIgAGgFMAByQCAAcAACa6JQAAIYIAIgUCCAAqCAYJLQsJBxsiAAeAzwAILQsBCQAqCAkKDioICgskAgALAAAm6yUAABVhLgIABYADKACABAQABCUAACAxLgiABQAIACIIAgkAKgkGCy0OCgstDggDGCoHBAURIgAFgEwABi0OBgEBIgACgE0ABS0KBQIjAAAmaioBAAEFWgLkG7UeqZ88BAIBJioBAAEFyW+TOxOd6RY8BAIBJg==","debug_symbols":"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","brillig_names":["get_latest_index"]},{"name":"public_dispatch","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"730596019049412512":{"error_kind":"string","string":"Function get_latest_data_and_index can only be called statically"},"798537054514309283":{"error_kind":"string","string":"Function get_as_much_latest_sliced_data can only be called statically"},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2830029349304997821":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"4704061078684901766":{"error_kind":"string","string":"Function get_block_number can only be called statically"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5386739060800882143":{"error_kind":"string","string":"Function get_2_slots_at_index can only be called statically"},"5534074920259783320":{"error_kind":"string","string":"Function get_latest_1_slot_data can only be called statically"},"5755000507507637366":{"error_kind":"string","string":"Function get_data_at_index can only be called statically"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6648186864564046035":{"error_kind":"string","string":"Function get_4_slots_latest_index can only be called statically"},"7032277157694375098":{"error_kind":"string","string":"Function get_4_slots_at_index can only be called statically"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"9193659048968351337":{"error_kind":"string","string":"Function get_8_slots_at_index can only be called statically"},"11104102707179475981":{"error_kind":"string","string":"Function get_2_slots_latest_index can only be called statically"},"11145567096809749512":{"error_kind":"string","string":"Function get_latest_data can only be called statically"},"12925009078149006190":{"error_kind":"string","string":"Function get_as_much_sliced_data_at_index can only be called statically"},"13265554733035650515":{"error_kind":"string","string":"BigNum::validate_gt check fails"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17263930005548814647":{"error_kind":"string","string":"Function get_8_slots_latest_index can only be called statically"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBIDcJwAABAMnAgIEAScCAwQAHwoAAgADgNsuCIDbAAElAAAARSUAAAwmKAIAAQSA3CcCAgQAOw4AAgABKwCAQwD/7u7u7u7u7u7u7u7u7u7vKwCARAYACAAAAAAAAAAAAAAAAAAAKACARQAAAikAgEYGAAEAACgAgEcGAAAuAAABgEgoAIBJBAAEAQAAAYBJAAEoAYBIBAABAQCASAACgEkuAIBJgEouBIBGgEoBAIBKAAKASi4EgEeASgEAgEoAAoBKLgSAR4BKKACASQQALCgAgEoBAAArAIBLBgEAAAAAAAAAAAAAAAAAAAAsAIBMAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAKACATQAgACgAgE4EAA0rAIBPBgCAAAAAAAAAAAAAAAAAAAAoAIBQBAABKACAUQQADigAgFIEAAIoAIBTBAAPKACAVAQAGigAgFUEABQoAIBWBAADKACAVwQAECgAgFgEAEQoAIBZBABQKACAWgQAGygAgFsEABUoAIBcBAA4KACAXQQAMigAgF4EAAQoAIBfBAARKACAYAQAQSgAgGEEAGAoAIBiBABFKACAYwQAUSgAgGQEAGkoAIBlBABjKACAZgQAHCgAgGcEABYoAIBoBABWKACAaQQAWigAgGoEADkoAIBrBAAzKACAbAQASCgAgG0EACooAIBuBAAFKACAbwQAfigAgHAEABIoAIBxBABCKACAcgQAMCgAgHMEAF4oAIB0BABhKACAdQQAVCgAgHYEAEYoAIB3BAB8KACAeAQAUigAgHkEAHooAIB6BABqKACAewQAZCgAgHwEAHIoAIB9BABsKACAfgQAHSgAgH8EABcoAICABABNKACAgQQAZigAgIIEAFcoAICDBABbKACAhAQAdygAgIUEAHQoAICGBAA6KACAhwQANCgAgIgEAD0oAICJBABuKACAigQASSgAgIsEACUoAICMBAArKACAjQQAHygAgI4EAAYoAICPBAB/KACAkAQAGSgAgJEEABMoAICSBABDKACAkwQATygAgJQEADcoAICVBAAxKACAlgQAQCgAgJcEAF8oAICYBABoKACAmQQAYigAgJoEAFUoAICbBABZKACAnAQARygAgJ0EACkoAICeBAB9KACAnwQALygAgKAEAF0oAIChBABTKACAogQAeygAgKMEAHkoAICkBABxKACApQQAaygAgKYEAEwoAICnBABlKACAqAQAdigAgKkEAHMoAICqBAA8KACAqwQAbSgAgKwEACQoAICtBAAeKACArgQADCgAgK8EABgoAICwBABOKACAsQQANigAgLIEAD8oAICzBABnKACAtAQAWCgAgLUEACgoAIC2BAAuKACAtwQAXCgAgLgEAHgoAIC5BABwKACAugQASygAgLsEAHUoAIC8BAA7KACAvQQAIygAgL4EAAsoAIC/BAA1KACAwAQAPigAgMEEACcoAIDCBAAtKACAwwQAbygAgMQEAEooAIDFBAAiKACAxgQACigAgMcEACYoAIDIBAAhKACAyQQACSgAgMoEACAoAIDLBAAIKACAzAQABygAgM0EAIAuAAABgM4oAIDPBACBAQAAAYDPAAEoAYDOBAABAQCAzgACgM8uAIDPgNAuBIBQgNABAIDQAAKA0C4EgFGA0AEAgNAAAoDQLgSAUoDQAQCA0AACgNAuBIBTgNABAIDQAAKA0C4EgFSA0AEAgNAAAoDQLgSAVYDQAQCA0AACgNAuBIBWgNABAIDQAAKA0C4EgFeA0AEAgNAAAoDQLgSAWIDQAQCA0AACgNAuBIBZgNABAIDQAAKA0C4EgFqA0AEAgNAAAoDQLgSAW4DQAQCA0AACgNAuBIBcgNABAIDQAAKA0C4EgF2A0AEAgNAAAoDQLgSAXoDQAQCA0AACgNAuBIBfgNABAIDQAAKA0C4EgGCA0AEAgNAAAoDQLgSAYYDQAQCA0AACgNAuBIBigNABAIDQAAKA0C4EgGOA0AEAgNAAAoDQLgSAZIDQAQCA0AACgNAuBIBlgNABAIDQAAKA0C4EgGaA0AEAgNAAAoDQLgSAZ4DQAQCA0AACgNAuBIBogNABAIDQAAKA0C4EgGmA0AEAgNAAAoDQLgSAaoDQAQCA0AACgNAuBIBrgNABAIDQAAKA0C4EgGyA0AEAgNAAAoDQLgSAbYDQAQCA0AACgNAuBIBugNABAIDQAAKA0C4EgG+A0AEAgNAAAoDQLgSAcIDQAQCA0AACgNAuBIBxgNABAIDQAAKA0C4EgHKA0AEAgNAAAoDQLgSAc4DQAQCA0AACgNAuBIB0gNABAIDQAAKA0C4EgHWA0AEAgNAAAoDQLgSAdoDQAQCA0AACgNAuBIB3gNABAIDQAAKA0C4EgHiA0AEAgNAAAoDQLgSAeYDQAQCA0AACgNAuBIB6gNABAIDQAAKA0C4EgHuA0AEAgNAAAoDQLgSAfIDQAQCA0AACgNAuBIB9gNABAIDQAAKA0C4EgH6A0AEAgNAAAoDQLgSAf4DQAQCA0AACgNAuBICAgNABAIDQAAKA0C4EgIGA0AEAgNAAAoDQLgSAgoDQAQCA0AACgNAuBICDgNABAIDQAAKA0C4EgISA0AEAgNAAAoDQLgSAhYDQAQCA0AACgNAuBICGgNABAIDQAAKA0C4EgIeA0AEAgNAAAoDQLgSAiIDQAQCA0AACgNAuBICJgNABAIDQAAKA0C4EgIqA0AEAgNAAAoDQLgSAi4DQAQCA0AACgNAuBICMgNABAIDQAAKA0C4EgI2A0AEAgNAAAoDQLgSAjoDQAQCA0AACgNAuBICPgNABAIDQAAKA0C4EgE6A0AEAgNAAAoDQLgSAkIDQAQCA0AACgNAuBICRgNABAIDQAAKA0C4EgJKA0AEAgNAAAoDQLgSAk4DQAQCA0AACgNAuBICUgNABAIDQAAKA0C4EgJWA0AEAgNAAAoDQLgSAloDQAQCA0AACgNAuBICXgNABAIDQAAKA0C4EgJiA0AEAgNAAAoDQLgSAmYDQAQCA0AACgNAuBICagNABAIDQAAKA0C4EgJuA0AEAgNAAAoDQLgSAnIDQAQCA0AACgNAuBICdgNABAIDQAAKA0C4EgJ6A0AEAgNAAAoDQLgSAn4DQAQCA0AACgNAuBICggNABAIDQAAKA0C4EgKGA0AEAgNAAAoDQLgSAooDQAQCA0AACgNAuBICjgNABAIDQAAKA0C4EgKSA0AEAgNAAAoDQLgSApYDQAQCA0AACgNAuBICmgNABAIDQAAKA0C4EgKeA0AEAgNAAAoDQLgSAqIDQAQCA0AACgNAuBICpgNABAIDQAAKA0C4EgKqA0AEAgNAAAoDQLgSAq4DQAQCA0AACgNAuBICsgNABAIDQAAKA0C4EgK2A0AEAgNAAAoDQLgSAroDQAQCA0AACgNAuBICvgNABAIDQAAKA0C4EgLCA0AEAgNAAAoDQLgSAsYDQAQCA0AACgNAuBICygNABAIDQAAKA0C4EgLOA0AEAgNAAAoDQLgSAtIDQAQCA0AACgNAuBIC1gNABAIDQAAKA0C4EgLaA0AEAgNAAAoDQLgSA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","debug_symbols":"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","brillig_names":["public_dispatch"]},{"name":"sync_private_state","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=","debug_symbols":"nZPfioQgFIff5Vx34f+0VxmGwcoGQSycWliid18bdKYWXJa58WSe7+tX6Qq9aZf7zfphfEBzWaEN1jl7v7mx07Mdfby7AtoHTKGhFWAGDY+FQ1PHIqBR21ZB7r/NwZi9/SCI2kkH42do/OJcBV/aLc+mx6T9s846xFVUgfF9rFE4WGf2q61606iMYsSZSDhGAvGXQvGTA5cdtcwGidiLF+TEkzLPCU885+9XwLT+bwBJ6xyAq1IAVuYZVYlnQn4UQLIcQMlSAFHm43dPvCDikwCKkCRQlJcCyD8CyLyHavTrF1zjVHc2nLb2tquC1a0zaTosvjuszt9TXslHYwpjZ/olmN10OB9xvGBZEXrd9qf9AA==","brillig_names":["sync_private_state"]},{"name":"update_feeds","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"feed_input_data","type":{"kind":"array","length":182,"type":{"kind":"field"}},"visibility":"private"},{"name":"feeds_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"indices_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"block_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"JwACBAEoAAABBID9JwAABAMnAgUEuScCBgQAHwoABQAGgEQdAID6gPoEHQCA+4D7BB0AgPyA/AQoAgABBIBEJwIGBLYtCAEFJwIHBLcACAEHAScDBQQBACIFAgcuAgABgAMuAgAHgAQuAgAGgAUlAAAApS0KBQEuCID6AAIuCID7AAMuCID8AAQlAAAA6yUAAAEBKAIAAQSA/ScCAgQAOw4AAgABAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAADqLgGACIAGLgSABoAJAQCACAACgAgBAIAJAAKACSMAAAC5JisAgEMA/+7u7u7u7u7u7u7u7u7u7yYlAAAEEB4CAAYAHgIABwAzKgAGAAcACCcCBgEBJAIACAAAASolAAAEOScCBwACLwoABwAIHgIABwEKKggHCSQCAAkAAAFQJwIKBAA8BgoBJwIHAAAvCgAHAAgcCggKBBwKCgkAHAoJCAQMKggECSQCAAkAAAGAJwIIBAA8BggBHAoECAAwCgAIAActCAEEAAABAgEnAgcEAC0OBwQnAgkEticCCgQBJwILBAInAgwEIC0KBwUjAAABugwqBQINJAIADQAAAtQjAAABzC0KBwIjAAAB1QwqAgMFJAIABQAAAkIjAAAB5ycCAgQBJwIEBAMAKgIEAy0IAQEACAEDAScDAQQBACIBAgMtDgIDACIDAgMtDgIDJwIDBAMAKgEDAi0KAgMtDggDACIBAgQtCwQDJwIFBAIAKgQFAjcLAAIAAyYtCwQFDCoFCQckAgAHAAACWCUAAARLACIBAgwAKgwFDS0LDQcBKIBDAAcADAAqBQoHDioFBw0kAgANAAAChSUAAARdDCoHCQ0kAgANAAAClyUAAARLACIBAg4AKg4HDy0LDw0wCgANAAwAKgULBw4qBQcMJAIADAAAAsIlAAAEXS0OBwQAKgIKBS0KBQIjAAAB1S0LBA4MKg4JDyQCAA8AAALqJQAABEsAIgECEAAqEA4RLQsRDwAqDgoQDioOEBEkAgARAAADDyUAAARdDCoQCREkAgARAAADISUAAARLACIBAhIAKhIQEy0LExEcChESBBwKEhAAHAoQEQQAKg4LEA4qDhASJAIAEgAAA1UlAAAEXS0OEAQMKhEMDiQCAA4AAANvJwIQBAA8BhABLQoHDSMAAAN4DCoNEQ4kAgAOAAADtyMAAAOKLQsEDQAqDREODioNDg8kAgAPAAADpSUAAARdLQ4OBAAqBQoNLQoNBSMAAAG6HAoNDgAAKg8OEC0LBA4AKg4NEg4qDhITJAIAEwAAA9wlAAAEXQwqEgkOJAIADgAAA+4lAAAESwAiAQITACoTEhQtCxQOMAoADgAQACoNCg4tCg4NIwAAA3goAIAEBHgADQAAAIAEgAMkAIADAAAEOCoBAAEF96Hzr6Wt1Mo8BAIBJioBAAEFvh4//z6k9vo8BAIBJioBAAEFxWvEWg4QAAI8BAIBJioBAAEFRafKcRlB5BU8BAIBJg==","debug_symbols":"tZjbbuM4DIbfxde5EEmRkvoqg0GRtukgQJAWmXaBRdF3X9IW7XYBCVh55yb5TMe/xaMVf0xPp4f3X/fn6/PL7+nux8f0cDtfLudf95eXx+Pb+eWq1o8p2AcKTnfxoN9pukv6nfQYgkLW8wAGXKGQQ1bgw0SBHIpCVoCoUAxKBUwVCB1kukNSiOCgv0HTYXRwi60PxSBVSFzBVriA3hRNOetNCRWK/oZMuZQFYogObomqTOp6FLPovWLWW5AGIRZ0qBYO6CAVABzcgm5BrkDBITqUCtEtMVcw36kYpAoCDlIhuSXlZc2c0SFVmH1XkKB3j8GAK4BbLE1RUylo6UeDVIHcEoMDV2C3cK4gWgCRDHKF5JZkguqXZLNkg1yhVEsK4CAV5hUaYFyykzBXIKpgZbOAXaXRSAwObhHV4WDAFZJbLHQz2MIWcEuRBbItjMFAKoBbwATV94zBwS2WbiYDrhDdYlmegclB48PqRbYKn2Fe4QxcYV6YprLMy9BSLxYfTgZcAd1igZrBArVAqmDx4WxgOhqfYqW1gOqIulzs7gu4xeKzQK5QqgWCBaiSSgoYWYgqrTZbncSZZhc+Pw+TT6H7t9vpZEPoy1jSYfV6vJ2ub9Pd9f1yOUx/HS/v849+vx6v8/fb8aZn9d6n65N+q+Dz+XIy+jxsV4f2pUBU/HLQkcOrROFvGtDRCIguESJuCvhNAdsKsYRUFWIBWRXkux/UVsjROmVWyFFiS6HrRSnuBUBpecG7vZA/6wXnNRe5mYvcUeDkXoAQtdZQ2gqFbSLNCkXFdnoB2PSiU9f6LPeaRPlSk/yvNXSKUmeid0bKDE03OlWZBL2mkj4WmhKxEwqIhdZYMDbLqhuMWNZgSGoGo1OZHLIHQ7HtSeoUN9v2aClu3Q0M+fElqVJafnQVshc3ptCMBIbdZYGwuywQ/4ey6LuCmyvSluiWZ/GkAsIWDd3YDuXkywPoP2Q1kawK3M5qrzgJPCWZsDRD0RucOnC3odUORXcZmHFdRmg+AKgTjBzy2mZA7Wdpb/yChPWJDhJppFfzKqFII1nNyKsCxQEFiug9QnFMQWhVEJaWAvWe6dlrU7enzWz0BFJYBZqZoE5hloRemLqhLQPJJAZ3gngwFTnvVGDZFBINKTBuCmNerA9S/Z8eWgox7u7wyLs7PMqf7XCSdbtLAjjU4Wnr8DI0I0r0/lTMQwqYNoWyV6E9I7oKKa4KaWQNBLDmQv/GDSnI2hyQxhSKe0EIQwqU1mmrf0tHFJDXBsWhHSIhpZ0KtPUFDfWFbkBgU2j2BcvuMSO4e8wIjY6Zn3p0fDzfvr2K/TS12/n4cDnVw+f36+OXs29/v/oZf5X7ent5PD29306mtL3P1Rc0P3SjTeWnvXPRAyh4gJLsEOxciAcM8vPTlvIP","brillig_names":["update_feeds"]}],"outputs":{"globals":{},"structs":{"functions":[{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AggregatedDataFeedStore::constructor_parameters"}}],"kind":"struct","path":"AggregatedDataFeedStore::constructor_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_id","type":{"kind":"field"}},{"name":"index","type":{"kind":"field"}},{"name":"start_slot","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_2_slots_at_index_parameters"}},{"name":"return_type","type":{"kind":"array","length":2,"type":{"kind":"field"}}}],"kind":"struct","path":"AggregatedDataFeedStore::get_2_slots_at_index_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_id","type":{"kind":"field"}},{"name":"start_slot","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_2_slots_latest_index_parameters"}},{"name":"return_type","type":{"kind":"array","length":2,"type":{"kind":"field"}}}],"kind":"struct","path":"AggregatedDataFeedStore::get_2_slots_latest_index_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_id","type":{"kind":"field"}},{"name":"index","type":{"kind":"field"}},{"name":"start_slot","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_4_slots_at_index_parameters"}},{"name":"return_type","type":{"kind":"array","length":4,"type":{"kind":"field"}}}],"kind":"struct","path":"AggregatedDataFeedStore::get_4_slots_at_index_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_id","type":{"kind":"field"}},{"name":"start_slot","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_4_slots_latest_index_parameters"}},{"name":"return_type","type":{"kind":"array","length":4,"type":{"kind":"field"}}}],"kind":"struct","path":"AggregatedDataFeedStore::get_4_slots_latest_index_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_id","type":{"kind":"field"}},{"name":"index","type":{"kind":"field"}},{"name":"start_slot","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_8_slots_at_index_parameters"}},{"name":"return_type","type":{"kind":"array","length":8,"type":{"kind":"field"}}}],"kind":"struct","path":"AggregatedDataFeedStore::get_8_slots_at_index_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_id","type":{"kind":"field"}},{"name":"start_slot","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_8_slots_latest_index_parameters"}},{"name":"return_type","type":{"kind":"array","length":8,"type":{"kind":"field"}}}],"kind":"struct","path":"AggregatedDataFeedStore::get_8_slots_latest_index_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_id","type":{"kind":"field"}},{"name":"start_slot","type":{"kind":"field"}},{"name":"slots","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_as_much_latest_sliced_data_parameters"}},{"name":"return_type","type":{"kind":"array","length":180,"type":{"kind":"field"}}}],"kind":"struct","path":"AggregatedDataFeedStore::get_as_much_latest_sliced_data_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_id","type":{"kind":"field"}},{"name":"index","type":{"kind":"field"}},{"name":"start_slot","type":{"kind":"field"}},{"name":"slots","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_as_much_sliced_data_at_index_parameters"}},{"name":"return_type","type":{"kind":"array","length":180,"type":{"kind":"field"}}}],"kind":"struct","path":"AggregatedDataFeedStore::get_as_much_sliced_data_at_index_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AggregatedDataFeedStore::get_block_number_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_block_number_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_id","type":{"kind":"field"}},{"name":"index","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_data_at_index_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_data_at_index_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_id","type":{"kind":"field"}},{"name":"start_slot","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_latest_1_slot_data_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_latest_1_slot_data_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_id","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_latest_data_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_latest_data_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_id","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_latest_data_and_index_parameters"}},{"name":"return_type","type":{"fields":[{"name":"latest_index","type":{"kind":"field"}},{"name":"latest_data","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::LatestDataAndIndex"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_latest_data_and_index_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_id","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_latest_index_parameters"}},{"name":"return_type","type":{"kind":"field"}}],"kind":"struct","path":"AggregatedDataFeedStore::get_latest_index_abi"},{"fields":[{"name":"parameters","type":{"fields":[],"kind":"struct","path":"AggregatedDataFeedStore::sync_private_state_parameters"}}],"kind":"struct","path":"AggregatedDataFeedStore::sync_private_state_abi"},{"fields":[{"name":"parameters","type":{"fields":[{"name":"feed_input_data","type":{"kind":"array","length":182,"type":{"kind":"field"}}},{"name":"feeds_len","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"indices_len","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"block_number","type":{"kind":"integer","sign":"unsigned","width":32}}],"kind":"struct","path":"AggregatedDataFeedStore::update_feeds_parameters"}}],"kind":"struct","path":"AggregatedDataFeedStore::update_feeds_abi"}]}},"file_map":{"12":{"path":"std/convert.nr","source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n"},"137":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/execution.nr","source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"},"139":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr","source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"},"17":{"path":"std/field/bn254.nr","source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"},"18":{"path":"std/field/mod.nr","source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"},"200":{"path":"/home/nrkostadinov/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr","source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"},"219":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr","source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"},"22":{"path":"std/lib.nr","source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n"},"25":{"path":"std/meta/expr.nr","source":"//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"},"262":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr","source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n"},"280":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr","source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{arrays::array_concat, field::{field_from_bytes, field_from_bytes_32_trunc}},\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"},"336":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr","source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"},"337":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr","source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"},"353":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr","source":"pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    get_split_order_hints::{get_split_order_hints_asc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::sort_by_counter_asc;\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\n// Returns the number of consecutive elements at the start of the array for which the predicate returns false.\n// This function ensures that any element after the first matching element (predicate returns true) also matches the predicate.\npub fn array_length_until<T, let N: u32, Env>(array: [T; N], predicate: fn[Env](T) -> bool) -> u32 {\n    let mut length = 0;\n    let mut stop = false;\n    for i in 0..N {\n        if predicate(array[i]) {\n            stop = true;\n        } else {\n            assert(\n                stop == false,\n                \"matching element found after already encountering a non-matching element\",\n            );\n            length += 1;\n        }\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n// Helper function to check if an array is padded with a given value from a given index.\n// Different to padded_array_length in that it allows the elements before the given index to be the same as the padded value.\npub fn array_padded_with<T, let N: u32>(array: [T; N], from_index: u32, padded_with: T) -> bool\nwhere\n    T: Eq,\n{\n    let mut is_valid = true;\n    let mut should_check = false;\n    for i in 0..N {\n        should_check |= i == from_index;\n        is_valid &= !should_check | (array[i] == padded_with);\n    }\n    is_valid\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nfn test_array_length_until() {\n    let array = [11, 22, 33, 44, 55];\n    assert_eq(array_length_until(array, |x| x == 55), 4);\n    assert_eq(array_length_until(array, |x| x == 56), 5);\n    assert_eq(array_length_until(array, |x| x > 40), 3);\n    assert_eq(array_length_until(array, |x| x > 10), 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_non_consecutive_fails() {\n    let array = [1, 1, 0, 1, 0];\n    let _ = array_length_until(array, |x| x == 0);\n}\n\n#[test(should_fail_with = \"matching element found after already encountering a non-matching element\")]\nfn test_array_length_until_first_non_matching_fails() {\n    let array = [1, 0, 0, 0, 0];\n    let _ = array_length_until(array, |x| x == 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test]\nfn test_array_padded_with() {\n    let array = [11, 22, 33, 44, 44];\n    assert_eq(array_padded_with(array, 0, 44), false);\n    assert_eq(array_padded_with(array, 1, 44), false);\n    assert_eq(array_padded_with(array, 2, 44), false);\n    assert_eq(array_padded_with(array, 3, 44), true);\n    assert_eq(array_padded_with(array, 4, 44), true);\n    assert_eq(array_padded_with(array, 4, 33), false);\n    assert_eq(array_padded_with(array, 5, 44), true); // Index out of bounds.\n    assert_eq(array_padded_with(array, 0, 11), false);\n}\n"},"356":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr","source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"},"369":{"path":"/home/nrkostadinov/nargo/github.com/noir-lang/noir-bignum/v0.7.3/src/bignum.nr","source":"use crate::fns::constrained_ops::limbs_to_field;\nuse crate::params::BigNumParams;\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub trait BigNum: Neg + Add + Sub + Mul + Div + Eq {\n    let N: u32;\n    let MOD_BITS: u32;\n\n    fn params() -> BigNumParams<N, MOD_BITS>;\n    fn modulus_bits(_: Self) -> u32;\n    fn num_limbs(_: Self) -> u32;\n    fn modulus() -> Self;\n\n    fn new() -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn from_limbs(limbs: [u128; N]) -> Self;\n    fn get_limbs(self) -> [u128; N];\n    fn set_limb(self: &mut Self, idx: u32, value: u128);\n    fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self;\n    fn from_be_bytes(x: [u8; (MOD_BITS + 7) / 8]) -> Self;\n    fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8];\n    fn from_le_bytes(x: [u8; (MOD_BITS + 7) / 8]) -> Self;\n    fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8];\n\n    fn get_limb(self: Self, idx: u32) -> u128 {\n        self.get_limbs()[idx]\n    }\n\n    unconstrained fn __eq(self: Self, other: Self) -> bool {\n        crate::fns::unconstrained_ops::__eq(self.get_limbs(), other.get_limbs())\n    }\n\n    unconstrained fn __is_zero(self: Self) -> bool {\n        crate::fns::unconstrained_ops::__is_zero(self.get_limbs())\n    }\n\n    unconstrained fn __neg(self) -> Self;\n    unconstrained fn __add(self, other: Self) -> Self;\n    unconstrained fn __sub(self, other: Self) -> Self;\n    unconstrained fn __mul(self, other: Self) -> Self;\n    unconstrained fn __div(self, other: Self) -> Self;\n    unconstrained fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    unconstrained fn __invmod(self) -> Self;\n    unconstrained fn __pow(self, exponent: Self) -> Self;\n\n    unconstrained fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    fn assert_is_not_equal(self: Self, other: Self) {\n        let params = Self::params();\n        crate::fns::constrained_ops::assert_is_not_equal(\n            params,\n            self.get_limbs(),\n            other.get_limbs(),\n        );\n    }\n\n    fn validate_in_range(self);\n    fn validate_in_field(self);\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self);\n    fn udiv(self, divisor: Self) -> Self;\n    fn umod(self, divisor: Self) -> Self;\n\n    fn is_zero(self) -> bool;\n}\n\n// we need macros that implement the BigNum, Default, From, Neg, Add, Sub, Mul, Div, Eq, Ord traits for each bignum type\npub(crate) comptime fn derive_bignum_impl(\n    strukt: TypeDefinition,\n    N: u32,\n    MOD_BITS: u32,\n    params: Quoted,\n) -> Quoted {\n    let constrained_ops = quote { crate::fns::constrained_ops };\n    let unconstrained_ops = quote { crate::fns::unconstrained_ops };\n    let typ = strukt.as_type();\n    let serialization = quote { crate::fns::serialization };\n    quote {\n\n        // implement BigNum for BigNum \n        impl crate::bignum::BigNum for $typ {\n            let N: u32 = $N; \n            let MOD_BITS: u32 = $MOD_BITS;\n            \n            fn modulus_bits(_: Self) -> u32 {\n                $MOD_BITS\n            }\n            \n            fn num_limbs(_: Self) -> u32 {\n                $N\n            }\n\n            fn modulus() -> Self {\n                Self { limbs: Self::params().modulus }\n            }\n\n            fn new() -> Self {\n                Self {limbs: [0; $N]}\n            }\n\n            fn params() -> crate::params::BigNumParams<$N, $MOD_BITS> {\n                $params\n            }\n\n            fn from_limbs(limbs: [u128; $N]) -> Self {\n                Self { limbs }\n            }\n\n            fn get_limbs(self: Self) -> [u128; $N] {\n                self.limbs\n            }\n\n            fn set_limb(self: &mut Self, idx: u32, value: u128) {\n                self.limbs[idx] = value;\n            }\n\n            fn zero() -> Self {\n                Self { limbs: [0; $N] }\n            }\n\n            fn one() -> Self {\n                let mut limbs = [0; $N];\n                limbs[0] = 1;\n                Self { limbs }\n            }\n\n            fn derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n                let params = Self::params();\n                $typ::from_limbs($constrained_ops::derive_from_seed::<_, $MOD_BITS, _>(params, seed))\n            }\n\n            unconstrained fn __derive_from_seed<let SeedBytes: u32>(seed: [u8; SeedBytes]) -> Self {\n                let params = Self::params();\n                Self { limbs: $unconstrained_ops::__derive_from_seed::<_, $MOD_BITS, _>(params, seed) }\n            }\n\n         \n\n            fn from_be_bytes(x: [u8; ($MOD_BITS + 7) / 8]) -> Self {\n                Self { limbs: $serialization::from_be_bytes::<_, $MOD_BITS>(x) }\n            }\n            \n            fn to_be_bytes(self) -> [u8; ($MOD_BITS + 7) / 8] {\n                $serialization::to_be_bytes::<_, $MOD_BITS>(self.limbs)\n            }\n\n            fn from_le_bytes(x: [u8; ($MOD_BITS + 7) / 8]) -> Self {\n                Self { limbs: $serialization::from_le_bytes::<_, $MOD_BITS>(x) }\n            }\n\n            fn to_le_bytes(self) -> [u8; ($MOD_BITS + 7) / 8] {\n                $serialization::to_le_bytes::<_, $MOD_BITS>(self.limbs)\n            }\n\n            unconstrained fn __neg(self: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__neg(params.modulus, self.get_limbs())}\n            }\n\n            unconstrained fn __add(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__add(params.modulus, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __sub(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__sub(params.modulus, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __mul(self: Self, other: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__mul(params, self.get_limbs(), other.get_limbs())}\n            }\n\n            unconstrained fn __div(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__div(params, self.get_limbs(), divisor.get_limbs())}\n            }\n\n            unconstrained fn __udiv_mod(self: Self, divisor: Self) -> (Self, Self) {\n                let (q, r) = $unconstrained_ops::__udiv_mod(self.get_limbs(), divisor.get_limbs());\n                (Self{limbs: q}, Self{limbs: r})\n            }\n\n            unconstrained fn __invmod(self: Self) -> Self {\n                let params = Self::params();\n                assert(params.has_multiplicative_inverse);\n                Self {limbs: $unconstrained_ops::__invmod(params, self.get_limbs())}\n            }\n\n            unconstrained fn __pow(self: Self, exponent: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $unconstrained_ops::__pow(params, self.get_limbs(), exponent.get_limbs())}\n            }\n\n            unconstrained fn __tonelli_shanks_sqrt(self: Self) -> std::option::Option<Self> {\n                let params = Self::params();\n                let maybe_limbs = $unconstrained_ops::__tonelli_shanks_sqrt(params, self.get_limbs());\n                maybe_limbs.map(|limbs| Self {limbs: limbs})\n            }\n\n            fn validate_in_field(self: Self) {\n                let params = Self::params();\n                $constrained_ops::validate_in_field::<_, $MOD_BITS>(params, self.get_limbs());\n            }\n\n            fn validate_in_range(self: Self) {\n                $constrained_ops::validate_in_range::<_, _, $MOD_BITS>(self.get_limbs());\n            }\n\n            fn udiv_mod(self: Self, divisor: Self) -> (Self, Self) {\n                let params = Self::params();\n                let (q, r) = $constrained_ops::udiv_mod::<_, $MOD_BITS>(params, self.get_limbs(), divisor.get_limbs());\n                (Self {limbs: q}, Self {limbs: r})\n            }\n\n            fn udiv(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $constrained_ops::udiv::<_, $MOD_BITS>(params, self.get_limbs(), divisor.get_limbs())}\n            }\n\n            fn umod(self: Self, divisor: Self) -> Self {\n                let params = Self::params();\n                Self {limbs: $constrained_ops::umod::<_, $MOD_BITS>(params, self.get_limbs(), divisor.get_limbs())}\n            }\n\n            fn is_zero(self: Self) -> bool {\n                $constrained_ops::is_zero::<_, $MOD_BITS>(self.get_limbs())\n            }\n        }\n\n        // implement Default for BigNum\n        impl Default for $typ {\n            fn default() -> Self {\n                $typ::from_limbs([0; $N])\n            }\n        }\n\n        impl std::convert::From<Field> for $typ {\n            fn from(input: Field) -> Self {\n                $typ { limbs: $constrained_ops::from_field::<$N, $MOD_BITS>($params, input) }\n            }\n        }\n\n        impl std::ops::Neg for $typ {\n            fn neg(self) -> Self {\n                $typ { limbs: $constrained_ops::neg::<$N, $MOD_BITS>($params, self.limbs) }\n            }\n        }\n\n        impl std::ops::Add for $typ {\n            fn add(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::add::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Sub for $typ {\n            fn sub(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::sub::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Mul for $typ {\n            fn mul(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::mul::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::ops::Div for $typ {\n            fn div(self, other: Self) -> Self {\n                $typ { limbs: $constrained_ops::div::<$N, $MOD_BITS>($params, self.limbs, other.limbs) }\n            }\n        }\n\n        impl std::cmp::Eq for $typ {\n            fn eq(self, other: Self) -> bool {\n                $constrained_ops::eq::<$N, $MOD_BITS>($params, self.limbs, other.limbs)\n            }\n        }\n\n        impl std::cmp::Ord for $typ {\n            fn cmp(self, other: Self) -> std::cmp::Ordering {\n                $constrained_ops::cmp::<$N, $MOD_BITS>(self.limbs, other.limbs)\n            }\n        }\n\n    }\n}\n\npub fn conditional_select<T: BigNum>(lhs: T, rhs: T, predicate: bool) -> T {\n    T::from_limbs(crate::fns::constrained_ops::conditional_select(\n        lhs.get_limbs(),\n        rhs.get_limbs(),\n        predicate,\n    ))\n}\n\npub unconstrained fn compute_quadratic_expression<T: BigNum, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    lhs_terms: [[T; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[T; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [T; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (T, T) {\n    let params = T::params();\n    let (q_limbs, r_limbs) = crate::fns::expressions::compute_quadratic_expression(\n        params,\n        crate::utils::map::map(\n            lhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        lhs_flags,\n        crate::utils::map::map(\n            rhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        rhs_flags,\n        crate::utils::map::map(linear_terms, |bn: T| bn.get_limbs()),\n        linear_flags,\n    );\n    (T::from_limbs(q_limbs), T::from_limbs(r_limbs))\n}\n\npub fn evaluate_quadratic_expression<T: BigNum, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    lhs_terms: [[T; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[T; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [T; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    let params = T::params();\n    crate::fns::expressions::evaluate_quadratic_expression(\n        params,\n        crate::utils::map::map(\n            lhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        lhs_flags,\n        crate::utils::map::map(\n            rhs_terms,\n            |bns| crate::utils::map::map(bns, |bn: T| bn.get_limbs()),\n        ),\n        rhs_flags,\n        crate::utils::map::map(linear_terms, |bn: T| bn.get_limbs()),\n        linear_flags,\n    )\n}\n\npub unconstrained fn batch_invert<T: BigNum, let M: u32>(x: [T; M]) -> [T; M] {\n    let params = T::params();\n    assert(params.has_multiplicative_inverse);\n    crate::fns::unconstrained_ops::batch_invert(params, x.map(|bn: T| bn.get_limbs())).map(|limbs| {\n        T::from_limbs(limbs)\n    })\n}\n\npub unconstrained fn batch_invert_slice<T: BigNum>(x: [T]) -> [T] {\n    let params = T::params();\n    assert(params.has_multiplicative_inverse);\n    crate::fns::unconstrained_ops::batch_invert_slice(params, x.map(|bn: T| bn.get_limbs()))\n        .map(|limbs| T::from_limbs(limbs))\n}\n\npub fn to_field<T: BigNum>(bn: T) -> Field {\n    let params = T::params();\n    limbs_to_field(params, bn.get_limbs())\n}\n"},"401":{"path":"/home/nrkostadinov/nargo/github.com/noir-lang/noir-bignum/v0.7.3/src/fns/constrained_ops.nr","source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = conditional_select::<N>(_params.modulus, grumpkin_modulus, gt_grumpkin);\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: u128 = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                limb += byte as u128 * need_more_bytes as u128;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    predicate: bool,\n) -> [u128; N] {\n    let mut result: [u128; N] = lhs;\n    for i in 0..N {\n        // (lhs[i] - rhs[i]) * predicate + rhs[i]\n        // in case lhs < rhs, this will underflow so we have to do one extra multiplication to prevent it\n        result[i] = lhs[i] * predicate as u128 + rhs[i] * (1 - predicate as u128);\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n"},"405":{"path":"/home/nrkostadinov/nargo/github.com/noir-lang/noir-bignum/v0.7.3/src/fns/unconstrained_helpers.nr","source":"use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift = (120 - limb_shift) as u8;\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> limb_shift);\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u8;\n    let remainder_shift: u8 = 120 - limb_shift as u8;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = bit % 120;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index as u8) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n"},"406":{"path":"/home/nrkostadinov/nargo/github.com/noir-lang/noir-bignum/v0.7.3/src/fns/unconstrained_ops.nr","source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n"},"415":{"path":"/home/nrkostadinov/nargo/github.com/noir-lang/noir-bignum/v0.7.3/src/utils/msb.nr","source":"global MUL_DE_BRUIJN_BIT: [u32; 128] = [\n    1, 14, 2, 15, 26, 20, 3, 16, 68, 80, 27, 21, 56, 50, 4, 17, 65, 96, 69, 81, 105, 99, 28, 22, 86,\n    90, 57, 51, 72, 42, 5, 126, 18, 66, 48, 94, 97, 84, 70, 124, 82, 122, 106, 100, 114, 108, 29,\n    23, 77, 102, 87, 91, 119, 116, 58, 52, 61, 110, 73, 37, 43, 31, 6, 127, 13, 25, 19, 67, 79, 55,\n    49, 64, 95, 104, 98, 85, 89, 71, 41, 125, 47, 93, 83, 123, 121, 113, 107, 76, 101, 118, 115, 60,\n    109, 36, 30, 12, 24, 78, 54, 63, 103, 88, 40, 46, 92, 120, 112, 75, 117, 59, 35, 11, 53, 62, 39,\n    45, 111, 74, 34, 10, 38, 44, 33, 9, 32, 8, 7, 128,\n];\n\npub(crate) unconstrained fn get_msb(x: u128) -> u32 {\n    let result = if x == 0 {\n        0\n    } else {\n        let mut v = x;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v |= v >> 32;\n        v |= v >> 64;\n        let index = (std::wrapping_mul(v, 0x1FC10C2FBCF471B913B14CD2595D6D5)) >> 121;\n        (index as Field).assert_max_bit_size::<32>();\n        MUL_DE_BRUIJN_BIT[index as u32]\n    };\n    result\n}\n\nmod tests {\n    use crate::constants::{TWO_POW_120, TWO_POW_60};\n    use crate::fns::unconstrained_helpers::__get_msb;\n    use super::get_msb as get_msb128;\n\n    fn assert_msb_equal(x: u64) {\n        let msb64 = unsafe { get_msb64(x) };\n        let msb128 = unsafe { get_msb128(x as u128) };\n        assert_eq(msb64, msb128);\n    }\n\n    #[test]\n    // To check that the msb functions are equivalent with de bruijn sequence for 64 bits and 128 bits\n    fn test_get_msb() {\n        // Test case 1: MSB at position 7\n        let x = 0x80; // binary: 10000000\n        assert_msb_equal(x);\n\n        // Test case 2: MSB at position 0\n        let x = 0x1; // binary: 00000001\n        assert_msb_equal(x);\n\n        // Test case 3: MSB at position 63\n        let x = 0x8000000000000000; // binary: 1000...0000 (63 zeros)\n        assert_msb_equal(x);\n\n        // Test case 4: Zero input\n        let x = 0x0;\n        assert_msb_equal(x);\n\n        // Test case 5: All bits set\n        let x = 0xFFFFFFFFFFFFFFFF;\n        assert_msb_equal(x);\n    }\n\n    /// Multiple entires in the `MUL_DE_BRUIJN_BIT` list do not map to a valid output of `v * 0x6c04f118e9966f6b`.\n    /// This is a dummy value to fill the gaps in the map.\n    global n1: u32 = 0xffffffff;\n\n    global MUL_DE_BRUIJN_BIT_64: [u32; 128] = [\n        0, // change to 1 if you want bitSize(0) = 1\n        48, n1, n1, 31, n1, 15, 51, n1, 63, 5, n1, n1, n1, 19, n1, 23, 28, n1, n1, n1, 40, 36, 46,\n        n1, 13, n1, n1, n1, 34, n1, 58, n1, 60, 2, 43, 55, n1, n1, n1, 50, 62, 4, n1, 18, 27, n1,\n        39, 45, n1, n1, 33, 57, n1, 1, 54, n1, 49, n1, 17, n1, n1, 32, n1, 53, n1, 16, n1, n1, 52,\n        n1, n1, n1, 64, 6, 7, 8, n1, 9, n1, n1, n1, 20, 10, n1, n1, 24, n1, 29, n1, n1, 21, n1, 11,\n        n1, n1, 41, n1, 25, 37, n1, 47, n1, 30, 14, n1, n1, n1, n1, 22, n1, n1, 35, 12, n1, n1, n1,\n        59, 42, n1, n1, 61, 3, 26, 38, 44, n1, 56,\n    ];\n\n    pub(crate) unconstrained fn get_msb64(x: u64) -> u32 {\n        let mut v = x;\n        v |= v >> 1;\n        v |= v >> 2;\n        v |= v >> 4;\n        v |= v >> 8;\n        v |= v >> 16;\n        v |= v >> 32;\n        let index = (std::wrapping_mul(v, 0x6c04f118e9966f6b)) >> 57;\n        (index as Field).assert_max_bit_size::<32>();\n        MUL_DE_BRUIJN_BIT_64[index as u32]\n    }\n\n    unconstrained fn __get_msb64<let N: u32>(val: [u128; N]) -> u32 {\n        let mut count = 0;\n        for i in 0..N {\n            let v = val[((N) - 1 - i)];\n            let v_low = v as u64 % TWO_POW_60 as u64;\n            let v_high = ((v - v_low as u128) / TWO_POW_60) as u64;\n            if (v_high > 0) {\n                count = 60 * ((2 * N) - 1 - (i * 2)) + get_msb64(v_high);\n                break;\n            }\n            if (v_low > 0) {\n                count = 60 * ((2 * N) - 1 - (i * 2 + 1)) + get_msb64(v_low);\n                break;\n            }\n        }\n        count\n    }\n\n    #[test]\n    // To check that the msb functions are equivalent with de bruijn sequence for 64 bits and 128 bits\n    unconstrained fn test_get_msb_equivalence() {\n        // Test single limb (64-bit number)\n        let x = 0x8000000000000000;\n        let arr = [0, 0, x as u128, 0];\n        let msb1 = __get_msb64(arr);\n        let msb2 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test multiple limbs (120-bit number)\n        let x = 0x800000000000000000000000000000; // 120 bits number\n        let arr = [0, 0, x as u128, 0];\n        let msb1 = __get_msb64(arr);\n        let msb2 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test zero\n        let arr = [0, 0, 0, 0];\n        let msb1 = __get_msb64(arr);\n        let msb2 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test all bits set (120 bits)\n        let x = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // 120 bits\n        let arr = [0, x as u128, 0, 0];\n        let msb1 = __get_msb64(arr);\n        let msb2 = __get_msb(arr);\n        assert_eq(msb1, msb2);\n\n        // Test systematic bit positions\n        for i in 0..120 {\n            let x: u128 = 1;\n            let shifted = x << i;\n            let arr = [0, shifted, 0, 0];\n            let msb1 = __get_msb64(arr);\n            let msb2 = __get_msb(arr);\n            assert_eq(msb1, msb2);\n        }\n\n        // Test random-like patterns (multiple bits set)\n        let patterns = [\n            0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, // alternating bits\n            0x555555555555555555555555555555, // alternating bits (opposite)\n            0x1234567890ABCDEF1234567890ABCD, // some pattern\n            0xFEDCBA0987654321FEDCBA09876543, // some pattern\n            0x800000000000000000000000000001, // highest and lowest bits\n            0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE, // all bits except lowest\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFF, // all bits except highest\n        ];\n        for i in 0..patterns.len() {\n            let arr = [0, patterns[i] as u128, 0, 0];\n            let msb1 = __get_msb64(arr);\n            let msb2 = __get_msb(arr);\n            assert_eq(msb1, msb2);\n        }\n\n        // Test with MSB in different array positions (120 bits)\n        let x = 0x800000000000000000000000000000; // 120 bits\n        let arr1 = [x as u128, 0, 0, 0];\n        let arr2 = [0, x as u128, 0, 0];\n        let arr3 = [0, 0, x as u128, 0];\n        let arr4 = [0, 0, 0, x as u128];\n        let msb1_1 = __get_msb64(arr1);\n        let msb2_1 = __get_msb(arr1);\n        assert_eq(msb1_1, msb2_1);\n\n        let msb1_2 = __get_msb64(arr2);\n        let msb2_2 = __get_msb(arr2);\n        assert_eq(msb1_2, msb2_2);\n\n        let msb1_3 = __get_msb64(arr3);\n        let msb2_3 = __get_msb(arr3);\n        assert_eq(msb1_3, msb2_3);\n\n        let msb1_4 = __get_msb64(arr4);\n        let msb2_4 = __get_msb(arr4);\n        assert_eq(msb1_4, msb2_4);\n    }\n\n    #[test]\n    unconstrained fn fuzz_get_msb(seed: [u128; 5]) {\n        let mut seed_copy = seed;\n        for i in 0..5 {\n            seed_copy[i] = seed_copy[i] & (TWO_POW_120 - 1);\n        }\n        let msb1 = __get_msb64(seed_copy);\n        let msb2 = __get_msb(seed_copy);\n        assert_eq(msb1, msb2);\n    }\n}\n"},"42":{"path":"std/option.nr","source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"},"43":{"path":"std/panic.nr","source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"},"50":{"path":"/home/nrkostadinov/aztec/AVM-Contracts/src/main.nr","source":"use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract AggregatedDataFeedStore {\n    use dep::aztec::macros::functions::{initializer, public, view};\n    use dep::aztec::prelude::PublicContext;\n    use dep::aztec::protocol_types::traits::{Deserialize, Serialize};\n    use dep::bignum::{BigNum, bignum::to_field, U256};\n    use std::meta::derive;\n\n    /// Max Fields that can be written in storage per Tx are 63.\n    /// Thus based on our calculations, we can pass at most 182 `Field`s for input data.\n    global MAX_INPUT_DATA_LEN: u32 = 182;\n    global TWO: Field = 2;\n    /// 2^13\n    global RING_BUFFER_SIZE: Field = 8192;\n    /// 2^16\n    global INDEX_VALUE_MAX_BITS_SIZE: U256 = U256::from(65536);\n    /// 2^115\n    global MAX_FEED_ID: u128 = 41538374868278621028243970633760768;\n    /// 2^128 - (2^120)/15   =====> [2^128 - (2^120)/15 to 2^128)\n    global RING_BUFFER_TABLE_ADDRESS: Field = 340193751721219469071847686961082855151;\n    /// 2^128                =====>  [2^128 to 2^160)\n    global DATA_FEED_ADDRESS: Field = 340282366920938463463374607431768211456;\n\n    #[derive(Serialize, Deserialize)]\n    pub struct LatestDataAndIndex {\n        latest_index: Field,\n        latest_data: Field,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor() {\n        context.storage_write(2, context.msg_sender()); // write the msg_sender at admin's slot.\n    }\n\n    ///                  [                                                                 .                                          ]\n    ///                  [  [------------------]  [----------------]  [-----------------]  .  [--------------------]  [------------]  ]\n    /// feed_input_data: [  | Feed computed id |  |   Feed's len   |  |   Feed's data   |  .  |  Ring buffer index |  | Index data |  ]\n    ///                  [  [------------------]  [----------------]  [-----------------]  .  [--------------------]  [------------]  ]\n    ///                  [                                                                 .                                          ]\n    ///                                           ^                ^                                     ^                 ^\n    ///                                           |                |                                     |                 |\n    ///                                         Repeats for every feed                                 Ring buffer index table\n    ///\n    #[public]\n    fn update_feeds(\n        feed_input_data: [Field; MAX_INPUT_DATA_LEN],\n        feeds_len: u32,\n        indices_len: u32,\n        block_number: u32,\n    ) {\n        assert(context.storage_read(2) == context.msg_sender());\n        assert(context.storage_read(0) < block_number);\n        context.storage_write(0, block_number);\n\n        let mut i: u32 = 0;\n        for _ in 0..feeds_len {\n            let feed_computed_index = feed_input_data[i];\n            let curr_feed_len = feed_input_data[i + 1] as u32;\n            i = i + 2;\n\n            // context.emit_public_log(feed_computed_index);\n            // context.emit_public_log(curr_feed_len);\n            assert(curr_feed_len < 32);\n            for j in 0..curr_feed_len {\n                context.storage_write(\n                    feed_computed_index + j as Field,\n                    feed_input_data[i + j] as Field,\n                );\n            }\n            i = i + curr_feed_len;\n        }\n\n        for _ in 0..indices_len {\n            context.storage_write(\n                RING_BUFFER_TABLE_ADDRESS + feed_input_data[i],\n                feed_input_data[i + 1],\n            );\n            i = i + 2;\n        }\n\n        context.emit_public_log(block_number);\n    }\n\n    #[public]\n    fn get_latest_index(feed_id: Field) -> Field {\n        let (stride, feed_id) = extract_stride_and_feed_id(feed_id);\n        // Cast feed_id to u128 for arithmetic operations.\n        let feed_id = feed_id as u128;\n        // Determine this feed's position (1-15) in its slot within the ring buffer.\n        let index_table_slot = feed_id % 15 + 1;\n        // Determine the bit position of this feed's 16-bit index, packed right to left (e.g., feed 1: bits 224-240).\n        let pos = 240 - (16 * index_table_slot);\n        // Compute the address where this slot's packed index values are stored.\n        let storage_address = RING_BUFFER_TABLE_ADDRESS\n            + (((MAX_FEED_ID * (stride as u128)) + feed_id) / 15) as Field;\n        let index_value = context.storage_read(storage_address);\n        // context.emit_public_log(index_value);\n        let index_value_bignum: U256 = U256::from(index_value);\n        let two_pow_pos_bignum: U256 = U256::from(TWO.pow_32(pos as Field));\n        // Right-shift the packed index to bring the target 16-bit value.\n        let (shifted, _) = index_value_bignum.__udiv_mod(two_pow_pos_bignum);\n        let (_, index_r) = shifted.__udiv_mod(INDEX_VALUE_MAX_BITS_SIZE);\n        to_field(index_r)\n    }\n\n    #[public]\n    #[view]\n    fn get_block_number() -> Field {\n        context.storage_read(0)\n    }\n\n    #[public]\n    #[view]\n    fn get_data_at_index(feed_id: Field, index: Field) -> Field {\n        context.storage_read(calculate_feed_index(feed_id, index))\n    }\n\n    #[public]\n    #[view]\n    fn get_latest_data(feed_id: Field) -> Field {\n        let latest_index = get_latest_index(feed_id);\n        context.storage_read(calculate_feed_index(feed_id, latest_index))\n    }\n\n    #[public]\n    #[view]\n    fn get_latest_data_and_index(feed_id: Field) -> pub LatestDataAndIndex {\n        let latest_index = get_latest_index(feed_id);\n        LatestDataAndIndex {\n            latest_index,\n            latest_data: context.storage_read(calculate_feed_index(feed_id, latest_index)),\n        }\n    }\n\n    #[public]\n    #[view]\n    fn get_latest_1_slot_data(feed_id: Field, start_slot: Field) -> Field {\n        let latest_index = get_latest_index(feed_id);\n        assert_index_within_feed_range(feed_id, latest_index, start_slot, 1);\n        get_slots_at_index::<1>(&mut context, feed_id, latest_index, start_slot, 1)[0]\n    }\n\n    #[public]\n    #[view]\n    fn get_as_much_latest_sliced_data(\n        feed_id: Field,\n        start_slot: Field,\n        slots: Field,\n    ) -> [Field; 180] {\n        let latest_index = get_latest_index(feed_id);\n        assert_index_within_feed_range(feed_id, latest_index, start_slot, slots);\n        get_slots_at_index::<180>(&mut context, feed_id, latest_index, start_slot, slots)\n    }\n\n    #[public]\n    #[view]\n    fn get_8_slots_latest_index(feed_id: Field, start_slot: Field) -> [Field; 8] {\n        let latest_index = get_latest_index(feed_id);\n        assert_index_within_feed_range(feed_id, latest_index, start_slot, 8);\n        get_slots_at_index::<8>(&mut context, feed_id, latest_index, start_slot, 8)\n    }\n\n    #[public]\n    #[view]\n    fn get_4_slots_latest_index(feed_id: Field, start_slot: Field) -> [Field; 4] {\n        let latest_index = get_latest_index(feed_id);\n        assert_index_within_feed_range(feed_id, latest_index, start_slot, 4);\n        get_slots_at_index::<4>(&mut context, feed_id, latest_index, start_slot, 4)\n    }\n\n    #[public]\n    #[view]\n    fn get_2_slots_latest_index(feed_id: Field, start_slot: Field) -> [Field; 2] {\n        let latest_index = get_latest_index(feed_id);\n        assert_index_within_feed_range(feed_id, latest_index, start_slot, 2);\n        get_slots_at_index::<2>(&mut context, feed_id, latest_index, start_slot, 2)\n    }\n\n    #[public]\n    #[view]\n    fn get_as_much_sliced_data_at_index(\n        feed_id: Field,\n        index: Field,\n        start_slot: Field,\n        slots: Field,\n    ) -> [Field; 180] {\n        assert_index_within_feed_range(feed_id, index, start_slot, slots);\n        get_slots_at_index::<180>(&mut context, feed_id, index, start_slot, slots)\n    }\n\n    #[public]\n    #[view]\n    fn get_8_slots_at_index(feed_id: Field, index: Field, start_slot: Field) -> [Field; 8] {\n        assert_index_within_feed_range(feed_id, index, start_slot, 8);\n        get_slots_at_index::<8>(&mut context, feed_id, index, start_slot, 8)\n    }\n\n    #[public]\n    #[view]\n    fn get_4_slots_at_index(feed_id: Field, index: Field, start_slot: Field) -> [Field; 4] {\n        assert_index_within_feed_range(feed_id, index, start_slot, 4);\n        get_slots_at_index::<4>(&mut context, feed_id, index, start_slot, 4)\n    }\n\n    #[public]\n    #[view]\n    fn get_2_slots_at_index(feed_id: Field, index: Field, start_slot: Field) -> [Field; 2] {\n        assert_index_within_feed_range(feed_id, index, start_slot, 2);\n        get_slots_at_index::<2>(&mut context, feed_id, index, start_slot, 2)\n    }\n\n    #[contract_library_method]\n    fn get_slots_at_index<let N: u32>(\n        context: &mut PublicContext,\n        feed_id: Field,\n        index: Field,\n        start_slot: Field,\n        slots: Field,\n    ) -> [Field; N] {\n        let mut slots_to_read = [0; N];\n        for i in start_slot as u32..slots as u32 {\n            slots_to_read[i] = read_slot(context, feed_id, index, i as Field);\n        }\n\n        slots_to_read\n    }\n\n    #[contract_library_method]\n    fn read_slot(\n        context: &mut PublicContext,\n        feed_id: Field,\n        index: Field,\n        offset: Field,\n    ) -> Field {\n        let slot_index = calculate_feed_index(feed_id, index) + offset;\n        context.storage_read(slot_index)\n    }\n\n    #[contract_library_method]\n    fn assert_index_within_feed_range(\n        feed_id: Field,\n        index: Field,\n        start_slot: Field,\n        slots: Field,\n    ) {\n        let max_read_index = calculate_feed_index(feed_id, index) + start_slot + (slots - 1);\n        let first_index_of_next_feed_id = calculate_feed_index(feed_id + 1, 0);\n        assert(max_read_index.lt(first_index_of_next_feed_id));\n    }\n\n    #[contract_library_method]\n    fn calculate_feed_index(feed_id: Field, index: Field) -> Field {\n        // In AVM, the relayer precomputes the feed index and passes it to the contract.\n        // This removes the need for the contract to calculate the index using the stride in `update_feeds`.\n        // Instead, the relayer provides the data along with the location of storage slots,\n        // reducing on-chain computation and improving overall efficiency.\n        let (stride, feed_id) = extract_stride_and_feed_id(feed_id);\n        assert(index as u128 < 8192);\n        // Note: `2**stride` is the analogy of `1 << stride`.\n        //\n        // Firstly, find the base feed index:               (feedId * 2**13) * 2**stride\n        // Then, find start slot for ring buffer index:     base_feed_index + index * 2**stride\n        // Lastly, we add it to the result of:              start_slot_ring_buffer_index + DATA_FEED_ADDRESS * 2**stride\n        (DATA_FEED_ADDRESS + (feed_id * RING_BUFFER_SIZE) + index) * TWO.pow_32(stride)\n    }\n\n    #[contract_library_method]\n    fn extract_stride_and_feed_id(feed_id: Field) -> (Field, Field) {\n        let stride_and_feed_id = feed_id as u128;\n        let stride = (stride_and_feed_id >> 120) as u8;\n        let feed_id = stride_and_feed_id & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n        assert(feed_id as u128 < MAX_FEED_ID);\n        assert(stride as u128 < 32);\n        (stride as Field, feed_id as Field)\n    }\n}\n"},"60":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/context/public_context.nr","source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"},"62":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/context/utility_context.nr","source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"},"88":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr","source":"use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"},"92":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr","source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"},"95":{"path":"/home/nrkostadinov/nargo/github.com/AztecProtocol/aztec-packages/v0.87.4/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr","source":"use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n\n    fn_abi\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"}}}