// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

<%_
let mainStructName = fields.name.charAt(0).toLowerCase() + fields.name.slice(1);
let containsDynamicData = false;

const expandFields = (values) => {
  const expandedFields = values.map((field) => {
    let data;
    if (field.type === 'tuple') {
      // This is a tuple field
      data = expandFields(field.components);
    } else if (field.type.includes('[')) {
      // This is an array field (potentially multi-dimensional)
      const dimensions = field.type.match(/\[(\d*)\]/g);
      data = expandArray(field.type, dimensions, field);
    } else {
      // This is not an array field, add it as is
      data = field;
    }
    return JSON.parse(JSON.stringify(data));
  });

  return expandedFields;
}

const expandArray = (baseType, dimensions, field) => {
  if (dimensions.length === 0 ||( !dimensions.some(dim => dim !== '[]') && !field.type.includes('tuple'))) {
    if (baseType === 'tuple') {
      return expandFields(field.components);
    } else {
      return {
        name: field.name,
        type: baseType,
        size: field.size,
        iterations: dimensions.length - 1,
        isDynamic: isDynamicType(baseType),
      };
    }
  }

  let lastDynamicDim = -1;
  for (let i = dimensions.length - 1; i >= 0; i--) {
    if (dimensions[i] !== '[]') {
      break;
    }
    lastDynamicDim = i;
  }

  let changed = dimensions.length
  if (lastDynamicDim > 0) {
    dimensions.splice(lastDynamicDim, dimensions.length - lastDynamicDim);
  }

  const currentDimension = dimensions[dimensions.length - 1];

  const size = currentDimension.match(/\[(\d*)\]/)[1];
  const arraySize = size ? parseInt(size) : 0;

  if (currentDimension === '[]' || lastDynamicDim > -1) {
    let components = []
    if (lastDynamicDim === 0) {
      components = expandArray(baseType.split('[')[0] + dimensions.slice(0, -1).join(''), dimensions.slice(0, -1), field);
    } else {
      components = expandArray(baseType + dimensions.join(''), dimensions, field);
    }
    return {
      name: field.name,
      type: baseType,
      size: field.size,
      iterations: changed - dimensions.length || 1,
      isDynamic: containsDynamicData = true,
      components: Array.isArray(components) ? components : [components],
    };
  }

  const result = [];

  for (let i = 0; i < arraySize; i++) {
    result.push(expandArray(baseType.split('[')[0] + dimensions.slice(0, -1).join(''), dimensions.slice(0, -1), field));
  }

  return result;
}

const isDynamicType = (type) => {
  return type === 'bytes' || type === 'string' || type.includes('[]');
}

function organizeFieldsIntoStructs(values) {
  let structs = [];
  let mainStruct = { name: fields.name, fields: [] };

  function processField(field, parentStruct) {
    if (field.type.includes('tuple')) {
      let newStruct = {
        name: field.name.charAt(0).toUpperCase() + field.name.slice(1),
        fields: []
      };
      if (field.components) {
        field.components.forEach(component => processField(component, newStruct));
      }
      structs.push(newStruct);

      let arrayDimensions = field.type.match(/(\[\d*\])+$/);
      if (arrayDimensions) {
        parentStruct.fields.push({ name: field.name, type: `${newStruct.name}${arrayDimensions[0]}` });
      } else {
        parentStruct.fields.push({ name: field.name, type: newStruct.name });
      }
    } else {
      parentStruct.fields.push({ name: field.name, type: field.type });
    }
  }

  values.forEach(field => processField(field, mainStruct));
  structs.unshift(mainStruct);

  return structs;
}
const organizedStructs = organizeFieldsIntoStructs(fields.components);

let prevSizeSum = 0;
function processFields(fields) {
  fields.forEach((field, index) => {
    if (Array.isArray(field)) {
      // If the field is an array, recursively process its elements
      field = processFields(field);
    } else if ('components' in field) {
      // If the field is a struct, recursively process its components
      if (field.isDynamic) {
        prevSizeSum = 0;
      }
      field.components = processFields(field.components);

      if (field.isDynamic) {
        prevSizeSum = 0;
      }
    } else {
      field.shift = 0;
      const isBytes = field.type.startsWith('bytes') && field.type !== 'bytes' && !field.type.endsWith('[]');
      const isDynamic = field.type === 'bytes' || field.type === 'string' || field.type.endsWith('[]');
      let fieldSize = field.size;
      // Handle bytes fields
      if (isBytes) {
        // Handle bytesNum
        if (prevSizeSum + fieldSize < 256) {
          field.shift = -prevSizeSum;
          prevSizeSum += fieldSize;
        } else {
          prevSizeSum = 0;
        }
      } else if (!isDynamic) {
        // Handle non-bytes fields
        if (prevSizeSum + fieldSize >= 256) {
          prevSizeSum = 0;
        }

        field.shift = 256 - prevSizeSum - fieldSize;
        prevSizeSum += fieldSize;
      } else {
        // Handle dynamic data
        field.isDynamic = true;
        containsDynamicData = true;
        prevSizeSum = 0;
      }

      if (!!!fieldSize) {
        field.size = 0;
      }
    }
  });

  return fields;
}

const expandedFields = processFields(expandFields([fields])).flat();

let wordOffset = 32;
let bitOffset = 0;
let prevSize = 0;
let shouldUpdate = false;
let shift = false;

function generateDecoderLines(expandedFields, name, startIndex = 0, indentation = '') {
  const lines = [];
  let index = startIndex;
  let location = name;

  for (let i = 0; i < expandedFields.length; i++) {
    const field = expandedFields[i];

    bitOffset += Array.isArray(field) || field.isDynamic ? 0 : field.size;

    if (!Array.isArray(field) && (prevSize + (field.size ?? 0) >= 256 || bitOffset >= 256)) {
      wordOffset += prevSize / 8;
      bitOffset = field.isDynamic ? 0 : field.size;
      shouldUpdate = true;
      prevSize = 0;
    }

    if (shouldUpdate && (wordOffset > 32 || shift)) {
      lines.push('');
      lines.push(`// Offset data with ${wordOffset} bytes`);
      lines.push(`memData := mload(add(data, ${shift ? wordOffset > 0 ? `add(shift, ${wordOffset})` : 'shift' : wordOffset}))`);
      lines.push('');
      shouldUpdate = false;
    }

    if (Array.isArray(field)) {
      const innerName = name + '_' + index;
      lines.push('');
      lines.push('{');
      lines.push(`  // Get address of field at slot ${index + 1} of ${name}`);
      lines.push(`  let ${innerName} := mload(${index ? `add(${name}, ${index * 0x20})` : name})`);
      const innerLines = generateDecoderLines(field, innerName, 0, '  ');
      lines.push(...innerLines);
      lines.push('}');
    } else if (!field.isDynamic) {
      prevSize += field.size;
      lines.push(`// Store the next ${field.size} bits of memData at slot ${index + 1} of ${location}`);
      lines.push(`mstore(${index ? `add(${location}, ${index * 0x20})` : location}, ${field.shift == 0 ? 'memData' : field.shift < 0 ? `shl(${Math.abs(field.shift)}, memData)` : field.size < 256 ? `and(shr(${field.shift}, memData), ${'0x' + 'F'.repeat(field.size / 4)})` : `shr(${field.shift}, memData)`})`);
    } else if (field.type === 'bytes' || field.type === 'string') {
      shift = true
      lines.push(...generateDecoderStringBytes(field, location, index, indentation));

      wordOffset = 0;
      prevSize = 0;
      bitOffset = 0;
    } else {
      shift = true;

      const isBytes = field.type.startsWith('bytes') && field.type !== 'bytes' && field.type !== 'bytes[]';
      const isDynamic = !isBytes && (field.type.startsWith('bytes') || field.type.startsWith('string'));

      const getArrayDepth = value => Array.isArray(value) ? 1 + Math.max(0, ...value.map(getArrayDepth)) : 0;

      // handles the fixed part of the type; handles dynamic arrays of tuples
      function handleNestedDynamic(field, innerName, depth, innerIndex, indentation) {
        const lines = [];
        const innerLocation = `${innerName}_${depth}`;
        lines.push('  {');
        lines.push(`    let ${innerLocation} := mload(0x40)`);
        if (!isNaN(innerIndex)) {
          lines.push(`    mstore(${innerIndex ? `add(${innerName}, ${innerIndex})` : innerName}, ${innerLocation})`);
        } else {
          lines.push(`    mstore(add(${innerName}, mul(add(${innerIndex}, 1), 32)), ${innerLocation})`);
        }
        lines.push(`    mstore(0x40, add(${innerLocation}, ${(field.components || field).length * 32}))`);
        const arrayDepth = getArrayDepth(field.components || field);
        if (arrayDepth > 1) {
          lines.push(...(field.components || field).map((innerField, index) => handleNestedDynamic(innerField, `${innerName}_${depth}`, depth + 1, index * 32, indentation + ' ')).flat(depth+1));
        } else {
          lines.push(...generateDecoderLines(field.components || field, innerLocation, 0, indentation + '  '));
        }
        if (wordOffset + prevSize / 8) {
          lines.push(`    shift := add(shift, ${wordOffset + prevSize / 8})`);
        }
        lines.push('  }');
        wordOffset = 0;
        prevSize = 0;

        return lines.map(line => line !== '' ? indentation + line : line)
      }

      // handles the '[]' part of the type
      function handleMultiDimensionalArray(iterations, type, currentLocation, indentation, depth = 0) {
        const innerType = type.slice(0, -2); // Remove last '[]'
        const innerIndex = `i_${location}_${depth}`;
        let innerName = `${location}_${depth}`;
        lines.push('');
        lines.push(indentation + `shift := add(shift, ${wordOffset + prevSize / 8 + 4})`);
        lines.push(indentation + '{');
        lines.push(indentation + `  // Get address of array at depth ${depth}`);
        // when main struct is a dynamic array
        if (currentLocation === mainStructName && fields.type.endsWith('[]')) {
          innerName = currentLocation
          lines.push(indentation + `  let ${innerName}_length := and(shr(${256 - bitOffset - 32}, memData), 0xFFFFFFFF)`);
        } else {
          lines.push(indentation + `  let ${innerName} := mload(0x40)`);
          lines.push(indentation + `  let ${innerName}_length := and(shr(${256 - bitOffset - 32}, memData), 0xFFFFFFFF)`);
          if (depth > 0) {
            lines.push(indentation + `  mstore(add(${currentLocation}, mul(add(i_${location}_${depth - 1}, 1), 32)), ${innerName})`);
          } else {
            lines.push(indentation + `  mstore(${index ? `add(${currentLocation}, ${index * 0x20})` : currentLocation}, ${innerName})`);
          }
          lines.push(indentation + `  mstore(0x40, add(${innerName}, mul(add(${innerName}_length, 1), 32)))`);
        }
        lines.push(indentation + `  mstore(${innerName}, ${innerName}_length)`);
        lines.push(indentation + `  memData := mload(add(data, shift))`);
        lines.push(indentation + '');
        lines.push(indentation + `  for {let ${innerIndex} := 0} lt(${innerIndex}, ${innerName}_length) {${innerIndex} := add(${innerIndex}, 1)} {`);

        wordOffset = 0;
        prevSize = 0;
        bitOffset = 0;

        if ('components' in field && !iterations) {
          lines.push(...handleNestedDynamic(field, innerName, depth, innerIndex, indentation + '  '));
          lines.push(`  memData := mload(add(data, shift))`);
        } else {
          handleCases({...field, type: innerType}, innerName, index, indentation + '    ', iterations, depth + 1, `${innerIndex}`);
        }

        lines.push(indentation + '  }');
        lines.push(indentation + '}');
      }

      function handleCases(field, location, index, indentation, iterations, depth = 0, parentIndex) {
        if (iterations) {
          handleMultiDimensionalArray(iterations - 1, field.type, location, indentation, depth);
        } else {
          if (isBytes) {
            lines.push(...generateDecoderFixedBytesLines(field, location, index, indentation, parentIndex));
          } else if (isDynamic) {
            lines.push(...generateDecoderDynamicDataLines(field, location, index, indentation, parentIndex));
          } else {
            lines.push(...generateDecoderPrimitiveLines(field, location, index, indentation, parentIndex));
          }
        }
      }

      handleCases(field, location, index, indentation, field.iterations);

      field.size = 0;
      wordOffset = 0;
      prevSize = 0;
      bitOffset = 0;
    }
    index++;
  }

  return lines.map(line => line !== '' ? indentation + line : line);
}

// dynamic array of bytes or string data
function generateDecoderDynamicDataLines(field, location, index, indentation, parentIndex) {
  const lines = [];

  const dataName = field.name + '_' + index;

  lines.push('');
  lines.push(`shift := add(shift, ${wordOffset + prevSize / 8 + 4})`);
  lines.push(`{`)
  lines.push(...generateMemoryAssignment(field.name, location, index, parentIndex));
  lines.push(`  memData := mload(add(data, shift))`)
  lines.push(`  for {`)
  lines.push(`    let ${dataName}_i := 0`)
  lines.push(`  } lt(${dataName}_i, ${field.name}_size) {`)
  lines.push(`    ${dataName}_i := add(${dataName}_i, 1)`)
  lines.push(`  } {`)

  wordOffset = 0;
  prevSize = 0;
  bitOffset = 0;

  lines.push(...generateDecoderStringBytes(field, field.name, index, '    ', dataName + '_i'));
  lines.push(`  }`)
  lines.push(`}`)

  return lines.map(line => line !== '' ? indentation + line : line);
}

// primitive types that are not bytes<num> are shifted to the right for Solidity to read
function generateDecoderPrimitiveLines(field, location, index, indentation, parentIndex) {
  const lines = [];

  lines.push('');
  lines.push(`shift := add(shift, ${wordOffset + prevSize / 8 + 4})`);
  lines.push(`{`);
  lines.push(...generateMemoryAssignment(field.name, location, index, parentIndex));
  if (field.size < 256) {
    lines.push(`  let prevSizeSum := 0`);
    lines.push(`  let offset := ${field.size + 32}`);
  }
  lines.push(`  for {`);
  lines.push(`    let ${field.name}_i := 0`);
  if (field.size >= 256) {
    lines.push(`    let shiftBytes := 0`);
  }
  lines.push(`  } lt(${field.name}_i, ${field.name}_size) {`);
  lines.push(`    ${field.name}_i := add(${field.name}_i, 1)`);
  if (field.size < 256) {
    lines.push(`    offset := add(offset, ${field.size})`);
    lines.push(`    prevSizeSum := add(prevSizeSum, ${field.size})`);
  } else {
    lines.push(`    shiftBytes := 32`);
  }
  lines.push(`  } {`);
  if (field.size < 256) {
    lines.push(`    if gt(offset, 256) {`);
    lines.push(`      shift := add(shift, div(prevSizeSum, 8))`);
    lines.push(`      memData := mload(add(data, shift))`);
    lines.push(`      offset := ${field.size}`);
    lines.push(`      prevSizeSum := 0`);
    lines.push(`    }`);
  } else {
    lines.push(`    shift := add(shift, shiftBytes)`);
    lines.push(`    memData := mload(add(data, shift))`);
  }
  lines.push(`    mstore(`);
  lines.push(`      add(${field.name}, mul(0x20, add(${field.name}_i, 1))),`);
  lines.push(`      ${field.size < 256 ? `and(shr(sub(256, offset), memData), ${'0x' + 'F'.repeat(field.size / 4)})` : `memData`}`);
  lines.push(`    )`);
  lines.push(`  }`);
  if (field.size < 256) {
    lines.push(...generateSwitchCase(field.size, 'gt(offset, 256)'));
  } else {
    lines.push(`  shift := add(shift, 32)`);
  }
  lines.push(`  memData := mload(add(data, shift))`);
  lines.push(`}`);

  return lines.map(line => line !== '' ? indentation + line : line);
}

// bytes<num> are shifted to the left for Solidity to read
function generateDecoderFixedBytesLines(field, location, index, indentation, parentIndex) {
  const lines = [];

  lines.push('');
  lines.push(`shift := add(shift, ${wordOffset + prevSize / 8 + 4})`);
  lines.push(`{`);
  lines.push(...generateMemoryAssignment(field.name, location, index, parentIndex));
  lines.push(`  let prevSizeSum := 0`);
  lines.push(`  let offset := ${bitOffset + 32}`);
  lines.push(`  for {`);
  lines.push(`    let ${field.name}_i := 0`);
  lines.push(`  } lt(${field.name}_i, ${field.name}_size) {`);
  lines.push(`    ${field.name}_i := add(${field.name}_i, 1)`);
  lines.push(`    offset := add(offset, ${field.size})`);
  lines.push(`    prevSizeSum := add(prevSizeSum, ${field.size})`);
  lines.push(`  } {`);
  lines.push(`    if gt(add(offset, ${field.size}), 256) {`);
  lines.push(`      shift := add(shift, div(prevSizeSum, 8))`);
  lines.push(`      memData := mload(add(data, shift))`);
  lines.push(`      offset := 0`);
  lines.push(`      prevSizeSum := 0`);
  lines.push(`    }`);
  lines.push(`    mstore(`);
  lines.push(`      add(${field.name}, mul(0x20, add(${field.name}_i, 1))),`);
  lines.push(`      shl(offset, memData)`);
  lines.push(`    )`);
  lines.push(`  }`);
  lines.push(...generateSwitchCase(field.size, `gt(add(offset, ${field.size}), 256)`));
  lines.push(`  memData := mload(add(data, shift))`);
  lines.push(`}`);

  return lines.map(line => line !== '' ? indentation + line : line);
}

// for generateDecoderFixedBytesLines(...) and generateDecoderPrimitiveLines(...) to align the memData shift
function generateSwitchCase(fieldSize, condition) {
  const lines = [];

  lines.push(`  switch ${condition}`);
  lines.push(`  case 1 {`);
  lines.push(`    shift := add(shift, div(prevSizeSum, 8))`);
  lines.push(`  }`);
  lines.push(`  default {`);
  lines.push(`    shift := add(shift, div(sub(offset, ${fieldSize + 32}), 8))`);
  lines.push(`  }`);

  return lines;
}

function generateDecoderStringBytes(field, location, index, indentation, parentIndex) {
  const lines = [];

  lines.push('');
  lines.push(`shift := add(shift, ${wordOffset + prevSize / 8 + 4})`);

  const fieldName = field.name + '_' + index;

  lines.push(`{`);
  lines.push(`  let ${fieldName} := mload(0x40)`);
  lines.push(`  let ${fieldName}_size := and(shr(${256 - bitOffset - 32}, memData), 0xFFFFFFFF)`);
  if (parentIndex) {
    lines.push(`  mstore(add(${location}, mul(add(${parentIndex}, 1), 32)), ${fieldName})`);
  } else {
    lines.push(`  mstore(${index ? `add(${location}, ${index * 0x20})` : location}, ${fieldName})`);
  }
  // take a mod of 32 to update the free memory pointer
  lines.push(`  mstore(0x40, add(${fieldName}, and(add(${fieldName}_size, 64), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFe0)))`);
  lines.push(`  mstore(${fieldName}, ${fieldName}_size)`);
  lines.push(`  let ${fieldName}_j := 32`);
  lines.push(`  for {`);
  lines.push(`  } lt(${fieldName}_j, ${fieldName}_size) {`);
  lines.push(`    ${fieldName}_j := add(${fieldName}_j, 32)`);
  lines.push(`    shift := add(shift, 32)`);
  lines.push(`  } {`);
  lines.push(`    memData := mload(add(data, shift))`);
  lines.push(`    mstore(add(${fieldName}, ${fieldName}_j), memData)`);
  lines.push(`  }`);
  lines.push(`  memData := mload(add(data, shift))`);
  lines.push(`  mstore(add(${fieldName}, ${fieldName}_j), memData)`);
  lines.push(`  ${fieldName}_j := mod(${fieldName}_size, 32)`)
  lines.push(`  if iszero(${fieldName}_j) {`)
  lines.push(`    ${fieldName}_j := 32`)
  lines.push(`  }`)
  lines.push(`  shift := add(shift, ${fieldName}_j)`)
  lines.push(`  memData := mload(add(data, shift))`);
  lines.push(`}`);

  return lines.map(line => line !== '' ? indentation + line : line);
}

// init memory allocation of free memory pointer for dynamic arrays
function generateMemoryAssignment(fieldName, location, index, parentIndex) {
  const lines = [];

  lines.push(`  let ${fieldName} := mload(0x40)`);
  lines.push(`  let ${fieldName}_size := and(shr(${256 - bitOffset - 32}, memData), 0xFFFFFFFF)`);
  if (parentIndex) {
    lines.push(`  mstore(add(${location}, mul(add(${parentIndex}, 1), 32)), ${fieldName})`);
  } else {
    lines.push(`  mstore(${index ? `add(${location}, ${index * 0x20})` : location}, ${fieldName})`);
  }
  lines.push(`  mstore(0x40, add(${fieldName}, mul(add(${fieldName}_size, 1), 32)))`);
  lines.push(`  mstore(${fieldName}, ${fieldName}_size)`);

  return lines;
}
-%>

/// @notice Decoder for stored packed sports data
library Decoder {
  /// @notice User defined struct
  /// @dev Using structs avoids hitting the EVM stack limit
<%= organizedStructs.map((struct) => {
  return `  struct ${struct.name} {
  ${struct.fields.map((fields) => `  ${fields.type} ${fields.name};`).join('\n  ')}
  }`
}).join('\n\n') %>

  function decode(
    bytes memory data
  ) external pure returns (<%= fields.name + (fields.type.match(/\[(\d*)\]/g) || []).join('') %> memory <%= mainStructName %>) {
    assembly {
      // First 32 bytes are the length of the data
      let memData := mload(add(data, 32))
      <%= containsDynamicData ? 'let shift := 0' : '' %>
      <%= generateDecoderLines(expandedFields, mainStructName).join('\n      ') %>
    }
  }
}
