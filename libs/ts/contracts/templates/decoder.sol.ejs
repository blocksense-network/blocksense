// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

<%_
let prevSizeSum = 0

let expandedFields = [];
let arraysCount = 0;
fields.forEach((field) => {
  if (field.type.endsWith(']')) {
    // This is an array field
    expandedFields.push({
      type: 'gap',
      isArray: true,
      arrayIndex: ++arraysCount,
      size: 0,
      length: field.length
    })
    for (let i = 0; i < field.length; i++) {
      expandedFields.push({
        type: field.type.split('[')[0], // Remove the '[]' from the type
        size: field.size,
        index: i,
      });
    }

    expandedFields.push({
      type: 'end',
      isArray: true,
      size: 0,
    })
  } else {
    // This is not an array field, add it as is
    expandedFields.push(field);
  }
});

expandedFields.forEach((field, index) => {
  field.shift = 0;
  const isBytes = field.type.startsWith('bytes');
  const isBytesMemory = field.type === 'bytes';

  let fieldSize = field.size;
  // Handle bytes fields
  if (isBytes) {
    if (prevSizeSum + fieldSize < 256) {
      // Handle bytesNum (not array or bytes memory)
      if (!isBytesMemory) {
        field.shift = index !== 0 ? -prevSizeSum : 0;
      }
      prevSizeSum += fieldSize;
    } else {
      prevSizeSum = 0;
    }
  } else {
    // Handle non-bytes fields
    if (prevSizeSum + fieldSize >= 256) {
      prevSizeSum = 0;
    }

    if(field.type !== 'end') {
      field.shift = 256 - prevSizeSum - fieldSize;
      prevSizeSum += fieldSize;
    }
  }
})-%>
/// @title Decoder
/// @notice Decoder for stored packed sports data
library Decoder {
  /// @notice User defined struct
  /// @dev Using structs avoids hitting the EVM stack limit
  struct SportsData {
    <%_ fields.forEach(field => { -%>
    <%= field.type %> <%= field.name -%>;
    <%_ }); -%>
  }

  function decode(
    bytes memory data
  ) external pure returns (SportsData memory sportsData) {
    assembly {
      let memData := mload(add(data, 32))
      <%_
      let wordOffset = 32
      let bitOffset = 0
      let prevSize = 0
      let index = 0
      let location = 'sportsData'
      -%>

      <%_ for (const [i, field] of expandedFields.entries()) { -%>
        <%_
        let shouldUpdate = false;
        if(i > 0) {
          prevSize += expandedFields[i - 1].size;
        }
        bitOffset += field.size

        if (prevSize + field.size >= 256) {
          // should be based on bitOffset or some other tracker for fields size
          wordOffset += prevSize / 8;
          bitOffset = field.size;
          shouldUpdate = true;
          prevSize = 0;
        }
        -%>
        <%_ if (shouldUpdate) { -%>
      memData := mload(add(data, <%= wordOffset %>))
        <%_ } -%>
        <%_ if (field.size <= 256) { -%>
          <%_ if (field.isArray) { -%>
            <%_ if (field.type === 'end') { -%>
              <%_ location = 'sportsData' -%>
            <%_ } else { -%>
              <%_ location = 'arrayAddress' + field.arrayIndex -%>

      let arrayAddress<%= field.arrayIndex %> := mload(<%= index ? `add(sportsData, ${index * 0x20})` : 'sportsData' %>)
              <%_ index++ -%>
              <%_ continue -%>
            <%_ } -%>
          <%_ } else if (!isNaN(field.index)) { -%>
      mstore(<%= field.index ? `add(${location}, ${field.index * 0x20})` : location %>, <%= field.shift == 0 ? 'memData' : field.shift < 0 ? `shl(${Math.abs(field.shift)}, memData)` : field.size < 256 ? `and(shr(${field.shift}, memData), ${'0x' + 'F'.repeat(field.size / 4)})` : `shr(${field.shift}, memData)` %>)
          <%_ } else { -%>
      mstore(<%= index ? `add(${location}, ${index * 0x20})` : location %>, <%= field.shift == 0 ? 'memData' : field.shift < 0 ? `shl(${Math.abs(field.shift)}, memData)` : field.size < 256 ? `and(shr(${field.shift}, memData), ${'0x' + 'F'.repeat(field.size / 4)})` : `shr(${field.shift}, memData)` %>)
            <%_ index ++ -%>
          <%_ } -%>
        <%_ } else { -%>
          // Handle larger types (bytes) here
        <%_ } -%>
        <%_ } _%>
    }
  }
}
