// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

<%_
let name = fields.name.charAt(0).toLowerCase() + fields.name.slice(1);
let containsDynamicData = false;

const expandFields = (values) => {
  const expandedFields = values.map((field) => {
    let data;
    if (field.type === 'tuple') {
      // This is a tuple field
      data = expandFields(field.components);
    } else if (field.type.includes('[')) {
      // This is an array field (potentially multi-dimensional)
      const dimensions = field.type.match(/\[(\d*)\]/g);
      data = expandArray(field.type, dimensions, field);
    } else {
      // This is not an array field, add it as is
      data = field;
    }
    return JSON.parse(JSON.stringify(data));
  });

  return expandedFields;
}

const expandArray = (baseType, dimensions, field) => {
  if (dimensions.length === 0 || !dimensions.some(dim => dim !== '[]')) {
    if (baseType.includes('tuple')) {
      return expandFields(field.components);
    } else {
      return {
        name: field.name,
        type: baseType,
        size: field.size,
        isDynamic: isDynamicType(baseType),
      };
    }
  }

  const currentDimension = dimensions[dimensions.length - 1];

  const size = currentDimension.match(/\[(\d*)\]/)[1];
  const arraySize = size ? parseInt(size) : 0;

  if (currentDimension === '[]') {
    return {
      name: field.name,
      type: baseType,
      size: field.size,
      isDynamic: containsDynamicData = true,
      components: expandArray(baseType.split('[')[0] + dimensions.slice(0, -1).join(''), dimensions.slice(0, -1), field),
    };
  }

  const result = [];

  for (let i = 0; i < arraySize; i++) {
    result.push(expandArray(baseType.split('[')[0] + dimensions.slice(0, -1).join(''), dimensions.slice(0, -1), field));
  }

  return result;
}

const isDynamicType = (type) => {
  return type === 'bytes' || type === 'string' || type.includes('[]');
}

function organizeFieldsIntoStructs(values) {
  let structs = [];
  let mainStruct = { name: fields.name, fields: [] };

  function processField(field, parentStruct) {
    if (field.type.includes('tuple')) {
      let newStruct = {
        name: field.name.charAt(0).toUpperCase() + field.name.slice(1),
        fields: []
      };
      if (field.components) {
        field.components.forEach(component => processField(component, newStruct));
      }
      structs.push(newStruct);

      let arrayDimensions = field.type.match(/(\[\d*\])+$/);
      if (arrayDimensions) {
        parentStruct.fields.push({ name: field.name, type: `${newStruct.name}${arrayDimensions[0]}` });
      } else {
        parentStruct.fields.push({ name: field.name, type: newStruct.name });
      }
    } else {
      parentStruct.fields.push({ name: field.name, type: field.type });
    }
  }

  values.forEach(field => processField(field, mainStruct));
  structs.unshift(mainStruct);

  return structs;
}
const organizedStructs = organizeFieldsIntoStructs(fields.values);

let prevSizeSum = 0;
function processFields(fields) {
  fields.forEach((field, index) => {
    if (Array.isArray(field)) {
      // If the field is an array, recursively process its elements
      field = processFields(field);
    } else if ('components' in field) {
      // If the field is a struct, recursively process its components
      field.components = processFields(field.components);
    } else {
      field.shift = 0;
      const isBytes = field.type.startsWith('bytes') && field.type !== 'bytes' && !field.type.endsWith('[]');
      const isDynamic = field.type === 'bytes' || field.type === 'string' || field.type.endsWith('[]');
      let fieldSize = field.size;
      // Handle bytes fields
      if (isBytes) {
        // Handle bytesNum
        if (prevSizeSum + fieldSize < 256) {
          field.shift = -prevSizeSum;
          prevSizeSum += fieldSize;
        } else {
          prevSizeSum = 0;
        }
      } else if (!isDynamic) {
        // Handle non-bytes fields
        if (prevSizeSum + fieldSize >= 256) {
          prevSizeSum = 0;
        }

        field.shift = 256 - prevSizeSum - fieldSize;
        prevSizeSum += fieldSize;
      } else {
        // Handle dynamic data
        field.isDynamic = true;
        containsDynamicData = true;
        prevSizeSum = 0;
      }

      if (!!!fieldSize) {
        field.size = 0;
      }
    }
  });


  return fields;
}

const expandedFields = processFields(expandFields(fields.values));

let wordOffset = 32;
let bitOffset = 0;
let prevSize = 0;
let shouldUpdate = false;
let shift = false;

function generateDecoderLines(expandedFields, name, startIndex = 0, indentation = '') {
  const lines = [];
  let index = startIndex;
  let location = name;

  for (let i = 0; i < expandedFields.length; i++) {
    const field = expandedFields[i];

    bitOffset += Array.isArray(field) || field.isDynamic ? 0 : field.size;

    if (!Array.isArray(field) && prevSize + field.size >= 256) {
      wordOffset += prevSize / 8;
      bitOffset = field.isDynamic ? 0 : field.size;
      shouldUpdate = true;
      prevSize = 0;
    }


    if (shouldUpdate && (wordOffset > 32 || shift)) {
      lines.push('');
      lines.push(`// Offset data with ${wordOffset} bytes`);
      lines.push(`memData := mload(add(data, ${shift ? wordOffset > 0 ? `add(shift, ${wordOffset})` : 'shift' : wordOffset}))`);
      lines.push('');
      shouldUpdate = false;
    }

    if (Array.isArray(field)) {
      const innerName = name + '_' + index;
      lines.push('');
      lines.push('{');
      lines.push(`  // Get address of field at slot ${index + 1} of ${name}`);
      lines.push(`  let ${innerName} := mload(${index ? `add(${name}, ${index * 0x20})` : name})`);
      const innerLines = generateDecoderLines(field, innerName, 0, '  ');
      lines.push(...innerLines);
      lines.push('}');
    } else if (!field.isDynamic) {
      prevSize += field.size;
      lines.push(`// Store the next ${field.size} bits of memData at slot ${index + 1} of ${location}`);
      lines.push(`mstore(${index ? `add(${location}, ${index * 0x20})` : location}, ${field.shift == 0 ? 'memData' : field.shift < 0 ? `shl(${Math.abs(field.shift)}, memData)` : field.size < 256 ? `and(shr(${field.shift}, memData), ${'0x' + 'F'.repeat(field.size / 4)})` : `shr(${field.shift}, memData)`})`);
    } else if (field.type === 'bytes' || field.type === 'string') {
      shift = true
      lines.push(...generateDecoderStringBytes(field, location, index, indentation));

      wordOffset = 0;
      prevSize = 0;
      bitOffset = 0;
    } else {
      shift = true;

      const isBytes = field.type.startsWith('bytes') && field.type !== 'bytes' && field.type !== 'bytes[]';
      const isDynamic = !isBytes && (field.type.startsWith('bytes') || field.type.startsWith('string'));

      function handleMultiDimensionalArray(dimensions, type, currentLocation, indentation, depth = 0) {
        const innerType = type.slice(0, -2); // Remove last '[]'
        const innerName = `${location}_${depth}`;
        const innerIndex = `i_${location}_${depth}`;
        lines.push('');
        lines.push(indentation + `shift := add(shift, ${wordOffset + prevSize / 8 + 4})`);
        lines.push(indentation + '{');
        lines.push(indentation + `  // Get address of array at depth ${depth}`);
        lines.push(indentation + `  let ${innerName} := mload(0x40)`);
        lines.push(indentation + `  let ${innerName}_length := and(shr(${256 - bitOffset - 32}, memData), 0xFFFFFFFF)`);
        if (depth > 0) {
          lines.push(indentation + `  mstore(add(${currentLocation}, mul(add(i_${location}_${depth - 1}, 1), 32)), ${innerName})`);
        } else {
          lines.push(indentation + `  mstore(${index ? `add(${currentLocation}, ${index * 0x20})` : currentLocation}, ${innerName})`);
        }
        lines.push(indentation + `  mstore(0x40, add(${innerName}, mul(add(${innerName}_length, 1), 32)))`);
        lines.push(indentation + `  mstore(${innerName}, ${innerName}_length)`);
        lines.push(indentation + `  memData := mload(add(data, shift))`);
        lines.push(indentation + '');
        lines.push(indentation + `  for {let ${innerIndex} := 0} lt(${innerIndex}, ${innerName}_length) {${innerIndex} := add(${innerIndex}, 1)} {`);

        wordOffset = 0;

        if ('components' in field) {
          const innerLocation = `${innerName}_${depth}`;
          lines.push(indentation + `    let ${innerLocation} := mload(0x40)`);
          lines.push(indentation + `    mstore(add(${innerName}, mul(add(${innerIndex}, 1), 32)), ${innerLocation})`);
          lines.push(indentation + `    mstore(0x40, add(${innerLocation}, mul(${field.components.length}, 32)))`);
          lines.push(...generateDecoderLines(field.components, innerLocation, 0, indentation + '    '));
          lines.push(indentation + `    shift := add(shift, ${wordOffset + prevSize / 8})`);
          lines.push(indentation + `    memData := mload(add(data, shift))`);
          wordOffset = 0;
        } else {
          handleCases({...field, type: innerType}, innerName, index, indentation + '    ', dimensions, depth + 1, `${innerIndex}`);
        }

        lines.push(indentation + '  }');
        lines.push(indentation + '}');
      }

      function handleCases(field, location, index, indentation, dimensions, depth = 0, parentIndex) {
        if (dimensions > 1) {
          // current index should be inner for the recursion and yet use
          handleMultiDimensionalArray(dimensions - 1, field.type, location, indentation, depth);
        } else {
          if (isBytes) {
            lines.push(...generateDecoderFixedBytesLines(field, location, index, indentation, parentIndex));
          } else if (isDynamic) {
            lines.push(...generateDecoderDynamicDataLines(field, location, index, indentation, parentIndex));
          } else {
            lines.push(...generateDecoderPrimitiveLines(field, location, index, indentation, parentIndex));
          }
        }
      }

      const dimensions = (field.type.match(/\[\]/g)).length;
      if ('components' in field) {
        handleMultiDimensionalArray(dimensions - 1, field.type, location, indentation);
      } else {
        handleCases(field, location, index, indentation, dimensions);
      }

      // FIXME
      field.size = 0;

      wordOffset = 0;
      prevSize = 0;
      bitOffset = 0;
    }
    index++;
  }

  return lines.map(line => line !== '' ? indentation + line : line);
}

function generateDecoderDynamicDataLines(field, location, index, indentation, parentIndex) {
  const lines = [];

  const dataName = field.name + '_' + index;

  lines.push('');
  lines.push(`shift := add(shift, ${wordOffset + prevSize / 8 + 4})`);
  lines.push(`{`)
  lines.push(`  let ${field.name} := mload(0x40)`)
  lines.push(`  let size := and(shr(${256 - bitOffset - 32}, memData), 0xFFFFFFFF)`);
  if (parentIndex) {
    lines.push(`  mstore(add(${location}, mul(add(${parentIndex}, 1), 32)), ${field.name})`);
  } else {
    lines.push(`  mstore(${index ? `add(${location}, ${index * 0x20})` : location}, ${field.name})`);
  }
  lines.push(`  mstore(0x40, add(${field.name}, mul(add(size, 1), 32)))`)
  lines.push(`  mstore(${field.name}, size)`)
  lines.push(`  memData := mload(add(data, shift))`)
  lines.push(`  for {`)
  lines.push(`    let ${dataName}_i := 0`)
  lines.push(`  } lt(${dataName}_i, size) {`)
  lines.push(`    ${dataName}_i := add(${dataName}_i, 1)`)
  lines.push(`  } {`)
  lines.push(`    shift := add(shift, 4)`)
  lines.push(`    {`)
  lines.push(`      let ${dataName} := mload(0x40)`)
  lines.push(`      let dynamicSize := and(shr(224, memData), 0xFFFFFFFF)`)
  lines.push(`      mstore(`)
  lines.push(`        add(${field.name}, mul(add(${dataName}_i, 1), 32)),`)
  lines.push(`        ${dataName}`)
  lines.push(`      )`)
  lines.push(`      mstore(`)
  lines.push(`        0x40,`)
  lines.push(`        add(${dataName}, mul(add(div(dynamicSize, 32), 2), 32))`)
  lines.push(`      )`)
  lines.push(`      mstore(${dataName}, dynamicSize)`)
  lines.push(`      let ${dataName}_j := 32`)
  lines.push(`      for {`)
  lines.push(`      } lt(${dataName}_j, dynamicSize) {`)
  lines.push(`        ${dataName}_j := add(${dataName}_j, 32)`)
  lines.push(`        shift := add(shift, 32)`)
  lines.push(`      } {`)
  lines.push(`        memData := mload(add(data, shift))`)
  lines.push(`        mstore(add(${dataName}, ${dataName}_j), memData)`)
  lines.push(`      }`)
  lines.push(`      memData := mload(add(data, shift))`)
  lines.push(`      mstore(add(${dataName}, ${dataName}_j), memData)`)
  lines.push(`      let shiftSize := mod(dynamicSize, 32)`)
  lines.push(`      switch shiftSize`)
  lines.push(`      case 0 {`)
  lines.push(`        shift := add(shift, 32)`)
  lines.push(`      }`)
  lines.push(`      default {`)
  lines.push(`        shift := add(shift, shiftSize)`)
  lines.push(`      }`)
  lines.push(`      memData := mload(add(data, shift))`)
  lines.push(`    }`)
  lines.push(`  }`)
  lines.push(`}`)

  return lines.map(line => line !== '' ? indentation + line : line);
}

function generateDecoderPrimitiveLines(field, location, index, indentation, parentIndex) {
  const lines = [];

  lines.push('');
  lines.push(`shift := add(shift, ${wordOffset + prevSize / 8 + 4})`);
  lines.push(`{`);
  lines.push(`  let ${field.name} := mload(0x40)`);
  lines.push(`  let size := and(shr(${256 - bitOffset - 32}, memData), 0xFFFFFFFF)`);
  if (parentIndex) {
    lines.push(`  mstore(add(${location}, mul(add(${parentIndex}, 1), 32)), ${field.name})`);
  } else {
    lines.push(`  mstore(${index ? `add(${location}, ${index * 0x20})` : location}, ${field.name})`);
  }
  lines.push(`  mstore(0x40, add(${field.name}, mul(add(size, 1), 32)))`);
  lines.push(`  mstore(${field.name}, size)`);
  if (field.size < 256) {
    lines.push(`  let prevSizeSum := 0`);
    lines.push(`  let offset := ${field.size + 32}`);
  }
  lines.push(`  for {`);
  lines.push(`    let ${field.name}_i := 0`);
  if (field.size >= 256) {
    lines.push(`    let shiftBytes := 0`);
  }
  lines.push(`  } lt(${field.name}_i, size) {`);
  lines.push(`    ${field.name}_i := add(${field.name}_i, 1)`);
  if (field.size < 256) {
    lines.push(`    offset := add(offset, ${field.size})`);
    lines.push(`    prevSizeSum := add(prevSizeSum, ${field.size})`);
  } else {
    lines.push(`    shiftBytes := 32`);
  }
  lines.push(`  } {`);
  if (field.size < 256) {
    lines.push(`    if gt(offset, 256) {`);
    lines.push(`      shift := add(shift, div(prevSizeSum, 8))`);
    lines.push(`      memData := mload(add(data, shift))`);
    lines.push(`      offset := ${field.size}`);
    lines.push(`      prevSizeSum := 0`);
    lines.push(`    }`);
  } else {
    lines.push(`    shift := add(shift, shiftBytes)`);
    lines.push(`    memData := mload(add(data, shift))`);
  }
  lines.push(`    mstore(`);
  lines.push(`      add(${field.name}, mul(0x20, add(${field.name}_i, 1))),`);
  lines.push(`      ${field.size < 256 ? `and(shr(sub(256, offset), memData), ${'0x' + 'F'.repeat(field.size / 4)})` : `memData`}`);
  lines.push(`    )`);
  lines.push(`  }`);
  if (field.size < 256) {
    lines.push(`  switch gt(offset, 256)`);
    lines.push(`  case 1 {`);
    lines.push(`    shift := add(shift, div(prevSizeSum, 8))`);
    lines.push(`  }`);
    lines.push(`  default {`);
    lines.push(`    shift := add(shift, div(sub(offset, ${field.size + 32}), 8))`);
    lines.push(`  }`);
  } else {
    lines.push(`  shift := add(shift, 32)`);
  }
  lines.push(`  memData := mload(add(data, shift))`);
  lines.push(`}`);

  return lines.map(line => line !== '' ? indentation + line : line);
}

function generateDecoderFixedBytesLines(field, location, index, indentation, parentIndex) {
  const lines = [];

  lines.push('');
  lines.push(`shift := add(shift, ${wordOffset + prevSize / 8 + 4})`);
  lines.push(`{`);
  lines.push(`  let ${field.name} := mload(0x40)`);
  lines.push(`  let size := and(shr(${256 - bitOffset - 32}, memData), 0xFFFFFFFF)`);
  if (parentIndex) {
    lines.push(`  mstore(add(${location}, mul(add(${parentIndex}, 1), 32)), ${field.name})`);
  } else {
    lines.push(`  mstore(${index ? `add(${location}, ${index * 0x20})` : location}, ${field.name})`);
  }
  lines.push(`  mstore(0x40, add(${field.name}, mul(add(size, 1), 32)))`);
  lines.push(`  mstore(${field.name}, size)`);
  lines.push(`  let prevSizeSum := 0`);
  lines.push(`  let offset := 32`);
  lines.push(`  for {`);
  lines.push(`    let ${field.name}_i := 0`);
  lines.push(`  } lt(${field.name}_i, size) {`);
  lines.push(`    ${field.name}_i := add(${field.name}_i, 1)`);
  lines.push(`    offset := add(offset, ${field.size})`);
  lines.push(`    prevSizeSum := add(prevSizeSum, ${field.size})`);
  lines.push(`  } {`);
  lines.push(`    if gt(add(offset, ${field.size}), 256) {`);
  lines.push(`      shift := add(shift, div(prevSizeSum, 8))`);
  lines.push(`      memData := mload(add(data, shift))`);
  lines.push(`      offset := 0`);
  lines.push(`      prevSizeSum := 0`);
  lines.push(`    }`);
  lines.push(`    mstore(`);
  lines.push(`      add(${field.name}, mul(0x20, add(${field.name}_i, 1))),`);
  lines.push(`      shl(offset, memData)`);
  lines.push(`    )`);
  lines.push(`  }`);
  lines.push(`  switch gt(add(offset, ${field.size}), 256)`);
  lines.push(`  case 1 {`);
  lines.push(`    shift := add(shift, div(prevSizeSum, 8))`);
  lines.push(`  }`);
  lines.push(`  default {`);
  lines.push(`    shift := add(shift, div(sub(offset, ${field.size + 32}), 8))`);
  lines.push(`  }`);
  lines.push(`  memData := mload(add(data, shift))`);
  lines.push(`}`);

  return lines.map(line => line !== '' ? indentation + line : line);
}

function generateDecoderStringBytes(field, location, index, indentation, parentIndex) {
  const lines = [];

  lines.push('');
  lines.push(`shift := add(shift, ${wordOffset + prevSize / 8 + 4})`);


  const fieldName = field.name + '_' + index;

  lines.push(`{`);
  lines.push(`  let ${fieldName} := mload(0x40)`);
  lines.push(`  let dynamicSize := and(shr(${256 - bitOffset - 32}, memData), 0xFFFFFFFF)`);
  if (parentIndex) {
    lines.push(`  mstore(add(${location}, mul(add(${parentIndex}, 1), 32)), ${fieldName})`);
  } else {
    lines.push(`  mstore(${index ? `add(${location}, ${index * 0x20})` : location}, ${fieldName})`);
  }
  lines.push(`  mstore(0x40, add(${fieldName}, and(add(dynamicSize, 64), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFe0)))`);
  lines.push(`  mstore(${fieldName}, dynamicSize)`);
  lines.push(`  let ${fieldName}_j := 32`);
  lines.push(`  for {`);
  lines.push(`  } lt(${fieldName}_j, dynamicSize) {`);
  lines.push(`    ${fieldName}_j := add(${fieldName}_j, 32)`);
  lines.push(`    shift := add(shift, 32)`);
  lines.push(`  } {`);
  lines.push(`    memData := mload(add(data, shift))`);
  lines.push(`    mstore(add(${fieldName}, ${fieldName}_j), memData)`);
  lines.push(`  }`);
  lines.push(`  memData := mload(add(data, shift))`);
  lines.push(`  mstore(add(${fieldName}, ${fieldName}_j), memData)`);
  lines.push(`  let shiftSize := mod(dynamicSize, 32)`);
  lines.push(`  switch shiftSize`);
  lines.push(`  case 0 {`);
  lines.push(`    shift := add(shift, 32)`);
  lines.push(`  }`);
  lines.push(`  default {`);
  lines.push(`    shift := add(shift, shiftSize)`);
  lines.push(`  }`);
  lines.push(`  memData := mload(add(data, shift))`);
  lines.push(`}`);

  return lines.map(line => line !== '' ? indentation + line : line);
}
-%>

/// @notice Decoder for stored packed sports data
library Decoder {
  /// @notice User defined struct
  /// @dev Using structs avoids hitting the EVM stack limit
<%= organizedStructs.map((struct) => {
  return `  struct ${struct.name} {
  ${struct.fields.map((fields) => `  ${fields.type} ${fields.name};`).join('\n  ')}
  }`
}).join('\n\n') %>

  function decode(
    bytes memory data
  ) external pure returns (<%= fields.name %> memory <%= name %>) {
    assembly {
      // First 32 bytes are the length of the data
      let memData := mload(add(data, 32))
      <%= containsDynamicData ? 'let shift := 0' : '' %>
      <%= generateDecoderLines(expandedFields, name).join('\n      ') %>
    }
  }
}
